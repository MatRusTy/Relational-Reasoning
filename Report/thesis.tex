\documentclass[twoside,11pt,openright]{report}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
% \usepackage{mathptmx}
\usepackage{stmaryrd}
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage[en-GB]{datetime2}
\DTMlangsetup[en-GB]{showdayofmonth=false}
\usepackage{lipsum}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}


% Theorems, Corollaries, and Lemmas
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BNF Grammar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\BNFdef}{::=}
\newcommand{\ALT}{~|~}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Syntax
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Keyword}[1]{{\color{blue} \mathsf{#1}}}

\newcommand{\var}{x}
\newcommand{\varB}{y}
\newcommand{\varC}{z}
\newcommand{\expr}{e}
\newcommand{\val}{v}
\newcommand{\valB}{w}
\newcommand{\TT}{()}
\newcommand{\Num}[1]{\overline{#1}}
\newcommand{\True}{\Keyword{true}}
\newcommand{\False}{\Keyword{false}}
\newcommand{\IfCmd}{\Keyword{if}}
\newcommand{\ThenCmd}{\Keyword{then}}
\newcommand{\ElseCmd}{\Keyword{else}}
\def\If#1then#2else#3{\IfCmd{}\;#1\;\ThenCmd{}\;#2\;\ElseCmd{}\;#3}
\newcommand{\Fst}{\Keyword{fst}\;}
\newcommand{\Snd}{\Keyword{snd}\;}
\newcommand{\Inj}[1]{\Keyword{inj}_{#1}\;}
\newcommand{\MatchCmd}{\Keyword{match}}
\newcommand{\WithCmd}{\Keyword{with}}
\newcommand{\EndCmd}{\Keyword{end}}
\def\Match#1with#2=>#3|#4=>#5end{\MatchCmd{}\;#1\;\WithCmd{}\;#2\Rightarrow#3 \;|\;#4\Rightarrow#5\;\EndCmd{}}
\def\MatchV[#1]#2with#3=>#4|#5=>#6end{\begin{aligned}[#1]&\MatchCmd{}\;#2\;\WithCmd{}\\ & \hspace{0.5em}#3\Rightarrow#4\\ & | \hspace{0.2em}#5\Rightarrow#6\\ &\EndCmd{}\end{aligned}}
\newcommand{\RecCmd}{\Keyword{rec}}
\long\def\Rec#1 #2:=#3{\RecCmd\; #1(#2) := #3}
\long\def\fun#1.#2{\lambda #1 .\; #2}
\newcommand{\LetCmd}{\Keyword{let}}
\newcommand{\InCmd}{\Keyword{in}}
\long\def\Let#1=#2in#3{\LetCmd \; #1 = #2 \; \InCmd \; #3}

\newcommand{\Tvar}{X}
\newcommand{\TvarB}{Y}
\newcommand{\TvarC}{Z}

\newcommand{\Tlam}{\Lambda\;}
\newcommand{\Tapp}[1]{#1\;\_}

\newcommand{\empelctx}{[]}
\newcommand{\elctx}{K}

\newcommand{\subst}[3]{#1{\left[#3 \middle/ #2 \right]}}

\newcommand{\empctx}{[\cdot]}
\newcommand{\ctx}{C}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Typing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Tunit}{\mathsf{Unit}}
\newcommand{\Temp}{\mathsf{Emp}}
\newcommand{\Tnat}{\mathbb{N}} % not needed
\newcommand{\Tint}{\mathbb{Z}}
\newcommand{\Tbool}{\mathbb{B}}
\newcommand{\Tprod}[2]{#1 \times #2}
\newcommand{\Tsum}[2]{#1 + #2}
\newcommand{\Tfunc}[2]{#1 \rightarrow #2}
\newcommand{\Tall}[2]{\forall #1.\; #2}

\newcommand{\typ}{\tau}
\newcommand{\venv}{\Gamma}
\newcommand{\tenv}{\Xi}
\newcommand{\hctx}{\Sigma} % not needed
\newcommand{\emptenv}{\bullet}
\newcommand{\empvenv}{\bullet}

% Sets
\newcommand{\VENV}{\mathrm{VENV}}
\newcommand{\TENV}{\mathrm{TENV}}
\newcommand{\EXPR}{\mathrm{EXPR}}
\newcommand{\TYPE}{\mathrm{TYPE}}

% Judgements
\newcommand{\jdg}[4]{#1 \; | \; #2 \; \vdash #3 : #4}
\newcommand{\jdgType}[3]{#1 \; | \; #2 \; \vdash #3}
\newcommand{\jdgRel}[6]{#1 \; | \; #2 \; \vdash #3 \approx^{#4} #5 : #6}
\newcommand{\ctxRel}[5]{\jdgRel{#1}{#2}{#3}{ctx}{#4}{#5}}

% Step
\newcommand{\step}{\rightarrow}
\newcommand{\stepS}{\rightarrow^*}

% Head-Step
\newcommand{\hstep}{\rightarrow_h}
\newcommand{\hstepRel}[2]{#1 \hstep #2}

% Logical Relation
\newcommand{\WtInp}[2]{\mathcal{W} \llbracket #1 \rrbracket_{#2}}
\newcommand{\WtInpGen}[2]{\WtInp{#1}{#2}(\val_1, \val_2)}
\newcommand{\ValInp}[2]{\mathcal{V} \llbracket #1 \rrbracket_{#2}}
\newcommand{\ValInpGen}[2]{\ValInp{#1}{#2}(\val_1, \val_2)}
\newcommand{\ExpInp}[2]{\mathcal{E} \llbracket #1 \rrbracket_{#2}}
\newcommand{\VenvInp}[2]{\mathcal{G} \llbracket #1 \rrbracket_{#2}}
\newcommand{\TenvInp}[1]{\mathcal{D} \llbracket #1 \rrbracket}

\newcommand{\LogRel}[5]{\jdgRel{#1}{#2}{#3}{LR}{#4}{#5}}

% Other
\newcommand{\Val}[1]{\mathrm{Val}(#1)}
\newcommand{\map}[2]{#1 \mapsto #2}

% TODO-command
\newcommand{\todo}[1]{{\color[rgb]{.5,0,0}\textbf{$\blacktriangleright$#1$\blacktriangleleft$}}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
{\Huge\sf Relational Reasoning\\[1ex](Relationel ræsonnement)}\\[4ex]
{\huge\sf Mathias Pedersen, 201808137}\\[2ex]
\noindent\rule{\linewidth}{1mm}\\[4ex]
\noindent{\Large\sf Bachelor Report (15 ECTS) in Computer Science\\[1ex]
Advisor: Amin Timany\\[1ex]
Department of Computer Science, Aarhus University\\[1ex]  
\today \\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage
\linespread{1.15}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

\todo{in English\dots}

\vspace{2ex}
\begin{flushright}
  \emph{Mathias Pedersen,}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\label{ch:intro}

\todo{motivate and explain the problem to be addressed}

\todo{get your bibtex entries from \url{https://dblp.org/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Definition of Language}
\label{ch:DoL}
To talk about contextual equivalence of programs, we first need to define a language, which captures what programs can be. Consequently, the choice of language influences the definition of contextual equivalence. We will see specifically how this manifests when we reach chapter \ref{ch:CE}. In this chapter, we will focus on formally defining the language, and showing some facts about it, which will be useful in later chapters.
\section{The language}
We define the language in three parts: the syntax, the typing rules, and finally the dynamics (semantics). The language we will be working with is generally refereed to as \textit{System F}, and we shall do so here as well. However, the features included in this language may be different from other presentations. We note here that we will be working with a Curry-style language, as opposed to a Church-style language. This essentially just means that types are not an intrinsic part of the semantics. Instead, types become a property that programs can have.
\subsection{Syntax}
The syntax captures exactly all programs that can be written in our language – in other words, it governs the "forms" our programs can take. We define it using a context-free grammar whose production rules are in Backus-Naur form:
\begin{align*}
  \expr \BNFdef & \TT \ALT & \text{(unit value)}\\
                & \var \ALT & \text{(variables)}\\
                & \Num{n} \ALT \expr + \expr \ALT \expr - \expr \ALT
                  \expr \le \expr \ALT \expr < \expr \ALT 
                  \expr = \expr \ALT & \text{(integers)}\\
                & \True \ALT \False \ALT {\If \expr then \expr else \expr} \ALT
                  & \text{(booleans)}\\
                & (\expr, \expr) \ALT \Fst \expr \ALT \Snd \expr \ALT
                  & \text{(products)}\\
                & \Inj{1} \expr \ALT \Inj{2} \expr \ALT 
                  \Match \expr with \Inj{1} \var => \expr | \Inj{2} \var => \expr end \ALT
                  & \text{(sums)}\\
                & \fun \var . \expr \ALT \expr \; \expr
                  & \text{(functions)}\\
                & \Tlam \expr \ALT \Tapp{\expr} & \text{(polymorphism)}
\end{align*}
\todo{question, is only 'e' part of syntax}
All programs in our language can be derived using the rules above. We shall also define a couple more concepts: values, types, and evaluation contexts.
\begin{align*}
  \val \BNFdef  & \TT \ALT \Num{n} \ALT \True \ALT \False \ALT
                  (\val, \val) \ALT \Inj{1} \val \ALT \Inj{2} \val \ALT
                  \fun \var . \expr \ALT \Tlam \expr
                  & \text{(values)}\\[8pt]
  \typ \BNFdef  & \Tunit \ALT \Tint \ALT \Tbool \ALT {\Tprod \typ \typ} \ALT
                  {\Tsum \typ \typ} \ALT {\Tfunc \typ \typ} \ALT 
                  {\Tall \Tvar \typ} & \text{(types)}\\[8pt]
  \elctx \BNFdef& \empelctx \ALT 
                  \elctx + \expr \ALT \val + \elctx \ALT
                  \elctx - \expr \ALT \val - \elctx \ALT
                  \elctx \le \expr \ALT \val \le \elctx \ALT
                  \elctx < \expr \ALT \val < \elctx \ALT 
                  & \text{(evaluation context)}\\
                & \elctx = \expr \ALT \val = \elctx \ALT
                  {\If \elctx then \expr else \expr} \ALT
                  (\elctx, \expr) \ALT (\val, \elctx) \ALT
                  \Fst \elctx \ALT \Snd \elctx \ALT\\
                & \Inj{1} \elctx \ALT \Inj{2} \elctx \ALT
                  \Match \elctx with \Inj{1} \var => \expr | \Inj{2} \var => \expr end \ALT
                  \elctx \; \expr \ALT \val \; \elctx \ALT \Tapp{\elctx}
\end{align*}
Evaluation contexts will be used when we get to defining the dynamics. In general, contexts like this are simply programs with a "hole". That hole can be plugged by some expressions $\expr$, and in that case we write $\elctx[\expr]$. We will see another example of a context in chapter \ref{ch:CE}.\\
Note that programs in our language may not necessarily make "sense". For example, using the rules above, we can construct the program $\True + 1$. To avert this problem, we introduce the typing rules, which will allow us to only talk about well-typed programs.

\subsection{Typing rules}
The typing rules give us a way to derive the type of a program in our language. They are defined using inference rules as follows:
\begin{mathpar}
  \inferrule*[lab=T-var]
    {(\var : \typ) \in \venv}
    {\jdg{\tenv}{\venv}{\var}{\typ}}
  \and
  \inferrule*[lab=T-unit]{ }{\jdg{\tenv}{\venv}{\TT}{\Tunit}}
  \and
  \inferrule*[lab=T-int]{ }{\jdg{\tenv}{\venv}{\Num{n}}{\Tint}}
  \and
  \inferrule*[lab=T-add]
    {{\jdg{\tenv}{\venv}{\expr_1}{\Tint}} \and {\jdg{\tenv}{\venv}{\expr_2}{\Tint}}}
    {\jdg{\tenv}{\venv}{\expr_1 + \expr_2}{\Tint}}
  \and
  \inferrule*[lab=T-sub]
    {{\jdg{\tenv}{\venv}{\expr_1}{\Tint}} \and {\jdg{\tenv}{\venv}{\expr_2}{\Tint}}}
    {\jdg{\tenv}{\venv}{\expr_1 - \expr_2}{\Tint}}
  \and
  \inferrule*[lab=T-le]
    {{\jdg{\tenv}{\venv}{\expr_1}{\Tint}} \and {\jdg{\tenv}{\venv}{\expr_2}{\Tint}}}
    {\jdg{\tenv}{\venv}{\expr_1 \le \expr_2}{\Tbool}}
  \and
  \inferrule*[lab=T-lt]
    {{\jdg{\tenv}{\venv}{\expr_1}{\Tint}} \and {\jdg{\tenv}{\venv}{\expr_2}{\Tint}}}
    {\jdg{\tenv}{\venv}{\expr_1 < \expr_2}{\Tbool}}
  \and
  \inferrule*[lab=T-eq]
    {{\jdg{\tenv}{\venv}{\expr_1}{\Tint}} \and {\jdg{\tenv}{\venv}{\expr_2}{\Tint}}}
    {\jdg{\tenv}{\venv}{\expr_1 = \expr_2}{\Tbool}}
  \and
  \inferrule*[lab=T-true]{ }{\jdg{\tenv}{\venv}{\True}{\Tbool}}
  \and
  \inferrule*[lab=T-false]{ }{\jdg{\tenv}{\venv}{\False}{\Tbool}}
  \and
  \inferrule*[lab=T-if]
    {{\jdg{\tenv}{\venv}{\expr_1}{\Tbool}} \and
    {\jdg{\tenv}{\venv}{\expr_2}{\typ}} \and
    {\jdg{\tenv}{\venv}{\expr_3}{\typ}}}
    {\jdg{\tenv}{\venv}{\If \expr_1 then \expr_2 else \expr_3}{\typ}}
  \and
  \inferrule*[lab=T-pair]
    {{\jdg{\tenv}{\venv}{\expr_1}{\typ_1}} \and
    {\jdg{\tenv}{\venv}{\expr_2}{\typ_2}}}
    {\jdg{\tenv}{\venv}{(\expr_1, \expr_2)}{\Tprod{\typ_1}{\typ_2}}}
  \and
  \inferrule*[lab=T-fst]
    {\jdg{\tenv}{\venv}{\expr}{\Tprod{\typ_1}{\typ_2}}}
    {\jdg{\tenv}{\venv}{\Fst \expr}{\typ_1}}
  \and
  \inferrule*[lab=T-snd]
    {\jdg{\tenv}{\venv}{\expr}{\Tprod{\typ_1}{\typ_2}}}
    {\jdg{\tenv}{\venv}{\Snd \expr}{\typ_2}}
  \and
  \inferrule*[lab=T-inj1]{\jdg{\tenv}{\venv}{\expr}{\typ_1}}
    {\jdg{\tenv}{\venv}{\Inj{1} \expr}{\Tsum{\typ_1}{\typ_2}}}
  \and
  \inferrule*[lab=T-inj2]{\jdg{\tenv}{\venv}{\expr}{\typ_2}}
    {\jdg{\tenv}{\venv}{\Inj{2} \expr}{\Tsum{\typ_1}{\typ_2}}}
  \and
  \inferrule*[lab=T-match]
    {{\jdg{\tenv}{\venv}{\expr}{\Tsum{\typ_1}{\typ_2}}} \and
    {\jdg{\tenv}{\venv, \var : \typ_1}{\expr_2}{\typ}} \and
    {\jdg{\tenv}{\venv, \var : \typ_2}{\expr_3}{\typ}}
    }
    {\jdg{\tenv}{\venv}{\Match \expr_1 with \Inj{1} \var => \expr_2 | \Inj{2} \var => \expr_3 end}{\typ}}
  \and
  \inferrule*[lab=T-lam]
    {\jdg{\tenv}{\venv, \var : \typ_1}{\expr}{\typ_2}}
    {\jdg{\tenv}{\venv}{\fun \var . \expr}{\Tfunc{\typ_1}{\typ_2}}}
  \and
  \inferrule*[lab=T-app]
    {{\jdg{\tenv}{\venv}{\expr_1}{\Tfunc{\typ_1}{\typ_2}}} \and
    {\jdg{\tenv}{\venv}{\expr_2}{\typ_1}}
    }
    {\jdg{\tenv}{\venv}{\expr_1 \; \expr_2}{\typ_2}}
  \and
  \inferrule*[lab=T-Tlam]
    {\jdg{\tenv, \Tvar}{\venv}{\expr}{\typ}}
    {\jdg{\tenv}{\venv}{\Tlam \expr}{\Tall{\Tvar}{\typ}}}
  \and
  \inferrule*[lab=T-Tapp]
  {\jdg{\tenv}{\venv}{\expr}{\Tall{\Tvar}{\typ}}}
  {\jdg{\tenv}{\venv}{\Tapp{\expr}}{\subst{\typ}{\Tvar}{\typ'}}}
\end{mathpar}

\subsection{Dynamics}
Finally, we define the semantics of the language. We do this using a single "step" rule, and several "head-step" rules. The head-step rules govern all possible reductions, and the "head-step-step" rule tells us where in our program we can apply these reductions.
\begin{mathpar}
  \inferrule*[lab=head-step-step]
    {\hstepRel{\expr}{\expr'}}
    {\elctx[\expr] \step \elctx[\expr']}
\end{mathpar}
The evaluation context, $\elctx$, is the part that tells us where in our program we may apply the reduction. If we have an expression $\expr$, and we have $\expr = \elctx[f]$, and $f \hstep f'$, then we may conclude that $\expr \step \elctx[f']$. Now, the head-steps are as follows:
\begin{mathpar}
  \inferrule*[lab=E-add]{}
    {\hstepRel{\Num{n_1} + \Num{n_2}} {\Num{n_1 + n_2}}}
  \and
  \inferrule*[lab=E-sub]{}
    {\hstepRel{\Num{n_1} - \Num{n_2}} {\Num{n_1 - n_2}}}
  \and
  \inferrule*[lab=E-eq]{n_1 = n_2}
    {\hstepRel{\Num{n_1} = \Num{n_2}} {\True}}
  \and
  \inferrule*[lab=E-not-eq]{n_1 \neq n_2}
    {\hstepRel{\Num{n_1} = \Num{n_2}} {\False}}
  \and
  \inferrule*[lab=E-le]{n_1 \le n_2}
    {\hstepRel{\Num{n_1} \le \Num{n_2}} {\True}}
  \and
  \inferrule*[lab=E-not-le]{n_1 \not\le n_2}
    {\hstepRel{\Num{n_1} \le \Num{n_2}} {\False}}
  \and
  \inferrule*[lab=E-lt]{n_1 < n_2}
    {\hstepRel{\Num{n_1} < \Num{n_2}} {\True}}
  \and
  \inferrule*[lab=E-not-lt]{n_1 \not< n_2}
    {\hstepRel{\Num{n_1} < \Num{n_2}} {\False}}
  \and
  \inferrule*[lab=E-if-true]{}
    {\hstepRel{\If \True then \expr_2 else \expr_3} {\expr_2}}
  \and
  \inferrule*[lab=E-if-false]{}
    {\hstepRel{\If \False then \expr_2 else \expr_3} {\expr_3}}
  \and
  \inferrule*[lab=E-fst]{}
    {\hstepRel{\Fst (\val_1, \val_2)} {\val_1}}
  \and
  \inferrule*[lab=E-snd]{}
    {\hstepRel{\Snd (\val_1, \val_2)} {\val_2}}
  \and
  \inferrule*[lab=E-match-inj1]{}
    {\hstepRel{\Match (\Inj{1} \val) with \Inj{1} \var => \expr_2 | \Inj{2} \var => \expr_3 end}
     {\subst{\expr_2}{\var}{\val}}}
  \and
  \inferrule*[lab=E-match-inj2]{}
    {\hstepRel{\Match (\Inj{2} \val) with \Inj{1} \var => \expr_2 | \Inj{2} \var => \expr_3 end}
     {\subst{\expr_3}{\var}{\val}}}
  \and
  \inferrule*[lab=E-lam-app]{}
    {\hstepRel{(\fun x . \expr) \; \val}
    {\subst{\expr}{\var}{\val}}
    }
  \and
  \inferrule*[lab=E-tapp-tlam]{}{\hstepRel{\Tapp{(\Tlam \expr)}}
  {\expr}}
\end{mathpar}
To strike home the workings of evaluation context, we give here an example. Let's say we want to show that $(\fun \var . \var) \; 2 + 3 \step (\fun \var . \var) \; 5$. Using the evaluation context $\elctx = (\fun \var . \var) \; \empelctx$, which is a valid evaluation context, we may conclude using the head-step-step rule that $\elctx[2 + 3] \step \elctx[5]$, if $2 + 3 \hstep 5$. By the E-add head-step rule, we know that $2 + 3 \hstep 5$, thus we have that $(\fun \var . \var) \; 2 + 3 \equiv \elctx[2 + 3] \step \elctx[5] \equiv (\fun \var . \var) \; 5$. Further, using $\elctx = \empelctx$ and the headstep rule E-lam-app, we may conclude $(\fun \var . \var) \; 5 \step \subst{\var}{\var}{5} \equiv 5$. We can hide the middle step, and simply write $(\fun \var . \var) \; 2 + 3 \step^2 5$, meaning that we perform two steps to reach $5$. We also introduce the notation $\expr \stepS \expr'$, which means that $\expr$ takes zero or more steps to reach $\expr'$. And if $\expr \stepS \val$, then we shall write $\expr \Downarrow \val$.\\
In the majority of the report, we will leave the evaluation contexts implicit and simply refer to the head-steps when justifying reductions.\medskip\\
At this point, our language has been formally defined, so next we will note down some facts and results about it.

\section{Properties of the language}
In this section we note down some useful properties of our language, which will help us reason about the concepts in later chapters. First we show some interesting lemmas about the evaluation context.

\subsection{Evaluation Context}
\begin{lemma}\label{lem:headstep_val}
  $\elctx[\expr] \hstep \expr' \land \neg (\elctx = \empelctx) \implies \Val{e}$
\end{lemma}
\begin{proof}
  This can be shown by doing case distinction on the head-step $\elctx[\expr] \hstep \expr'$. We show it here only for case E-ADD, as all the other cases are similar. \medskip\\
  So assume $\elctx[\expr] = \Num{n_1} + \Num{n_2}$, and $\expr' = \Num{n_1 + n_2}$.
  Then there are three cases: $\elctx = []$ and $\expr = \Num{n_1} + \Num{n_2}$, $\elctx = [] + \Num{n_2}$ and $\expr = \Num{n_1}$, or $\elctx = \Num{n_1} + []$ and $\expr = \Num{n_2}$. The first case raises a contradiction as we have assumed $\neg (\elctx = \empelctx)$. In the remaining two cases, we may conclude $\Val{\expr}$, as wanted.
\end{proof}


\begin{lemma}[Evaluation under Context]\label{lem:EuC}
  $ \elctx[\expr] \stepS \expr' \implies 
    \exists \expr'' . (\expr \stepS \expr'') \land\\
    \left( (\Val{\expr''} \land \elctx[\expr''] \stepS \expr') \lor
    (\neg \Val{\expr''} \land \elctx[\expr''] = \expr') \right)
    $
\end{lemma}
\begin{proof}
  So assuming $\elctx[\expr] \stepS \expr'$, we must show
  \begin{equation}\label{eqn:EuCGoal}
    \exists \expr'' . (\expr \stepS \expr'') \land 
    \left( (\Val{\expr''} \land \elctx[\expr''] \stepS \expr') \lor
    (\neg \Val{\expr''} \land \elctx[\expr''] = \expr') \right)
  \end{equation}
  We proceed by induction on the number of steps in the evaluation $\elctx[\expr] \stepS \expr'$. Let $n$ denote the number of steps taken, so that $\elctx[\expr] \step^n \expr'$.
  \begin{itemize}
    \item Base Case $n = 0$. In this case, we have that $\elctx[\expr] \step^0 \expr'$, which means that $\elctx[\expr] = \expr'$. Now use $\expr$ for $\expr''$ in \ref{eqn:EuCGoal}. We must show
    \begin{equation*}
      (\expr \stepS \expr) \land 
      \left( (\Val{\expr} \land \elctx[\expr] \stepS \expr') \lor
      (\neg \Val{\expr} \land \elctx[\expr] = \expr') \right)
    \end{equation*}
    Trivially, $\expr \stepS \expr$. For the second part, we proceed by case distinction on $\Val{\expr}$.
    \begin{itemize}
      \item $\Val{\expr}$. We have that $\elctx[\expr] \step^0 \expr'$, so $\elctx[\expr] \stepS \expr'$. Thus, we have $\Val{\expr} \land \elctx[\expr] \stepS \expr'$, which matches the left part of the "$\lor$".
      \item $\neg \Val{\expr}$. We know that $\elctx[\expr] = \expr'$, so we have $\neg \Val{\expr} \land \elctx[\expr] = \expr'$, which matches the right part of the "$\lor$".
    \end{itemize}
    
    \item Inductive Step $n = m + 1$. Now we have $\elctx[\expr] \step^{m + 1} \expr'$. By the Induction Hypothesis, we have:
    \begin{multline}\label{eqn:EuCIH}
      \forall F, f, f'. F[f] \step^m f' \implies \exists f'' . (f \stepS f'') \land \\
      \left( (\Val{f''} \land F[f''] \stepS f') \lor
      (\neg \Val{f''} \land \elctx[f''] = f') \right)
    \end{multline}
    Split the evaluation, $\elctx[\expr] \step^{m + 1} \expr'$, up, so that 
    $\elctx[\expr] \step g \land g \step^{m} \expr'$. Looking at our dynamics, we must have that $\elctx[\expr] = H[h]$, and $g = H[h']$, for some evaluation context $H$, and expressions $h$, $h'$, and $h \hstep h'$.
    There are now three possible cases. Either $\expr = h$, $\expr$ is a superexpression of $h$, or $\expr$ is a subexpression of $h$. We will consider each in turn.
    \begin{itemize}
      \item $\elctx = H$ and $\expr = h$.\\
        Then $g = H[h'] = \elctx[h']$, and $\expr \hstep h'$. 
        Furthermore, $\elctx[h'] \step^m \expr'$. Instantiate I.H. with this to get
        \begin{multline}\label{eqn:EuCC1IH}
          \exists f'' . (h' \stepS f'') \land\\
          \left((\Val{f''} \land \elctx[f''] \stepS \expr') \lor
          (\neg \Val{f''} \land \elctx[f''] = \expr') \right)
        \end{multline}
        Call this quantified expression for $f''$, and use it for $\expr''$ in \ref{eqn:EuCGoal}. We must then show
        \begin{equation*}
          (\expr \stepS f'') \land 
          \left( (\Val{f''} \land \elctx[f''] \stepS \expr') \lor
          (\neg \Val{f''} \land \elctx[f''] = \expr') \right)
        \end{equation*}
        We know that $\expr \step h'$, as $\expr \hstep h'$, and by 
        \ref{eqn:EuCC1IH}, we know that $h' \stepS f''$, so that $\expr \stepS f''$. The second part follows directly from \ref{eqn:EuCC1IH}.
      
      \item $\elctx[E[]] = H$ and $\expr = E[h]$.\\
        Then $g = H[h'] = \elctx[E[]][h'] = \elctx[E[h']]$, thus $\elctx[E[h']] \step^m \expr'$. Instantiate I.H. with this to get
        \begin{multline}\label{eqn:EuCC2IH}
          \exists f'' . (E[h'] \stepS f'') \land\\
          \left((\Val{f''} \land \elctx[f''] \stepS \expr') \lor
          (\neg \Val{f''} \land \elctx[f''] = \expr') \right)
        \end{multline}
        Call this quantified expression for $f''$, and use it for $\expr''$ in \ref{eqn:EuCGoal}. We must then show
        \begin{equation*}
          (\expr \stepS f'') \land 
          \left( (\Val{f''} \land \elctx[f''] \stepS \expr') \lor
          (\neg \Val{f''} \land \elctx[f''] = \expr') \right)
        \end{equation*}
        We know that $E[h] \step E[h']$, as $h \hstep h'$, and since $\expr = E[h]$, then $\expr \step E[h']$. By 
        \ref{eqn:EuCC2IH}, we know that $E[h'] \stepS f''$, so that $\expr \stepS f''$. The second part follows directly from \ref{eqn:EuCC2IH}.

      \item $\elctx = H[E[]]$ and $E[\expr] = h$.
        Here we have $h = E[\expr]$, so $E[\expr] \hstep h'$. Note that $E$ is not the empty evaluation context, as otherwise, we would be in case 1. So by lemma \ref{lem:headstep_val}, we know that $\Val{\expr}$. Now, pick $\expr$ for $\expr''$ in \ref{eqn:EuCGoal}. We must show 
        \begin{equation*}
          (\expr \stepS \expr) \land 
          \left( (\Val{\expr} \land \elctx[\expr] \stepS \expr') \lor
          (\neg \Val{\expr} \land \elctx[\expr] = \expr') \right)
        \end{equation*}
        Trivially, $\expr \stepS \expr$. We also have that $\Val{\expr}$, and since $\elctx[\expr] \step^{m + 1} \expr'$, then $\elctx[\expr] \stepS \expr'$.
    \end{itemize}
  \end{itemize}
\end{proof}

\begin{corollary}\label{cor:EuC_val}
  $\elctx[\expr] \stepS \val \implies \exists \expr'' . (\expr \stepS \expr'') \land (\Val{\expr''} \land \elctx[\expr''] \stepS \val)$
\end{corollary}
\begin{proof}
  Assuming $\elctx[\expr] \stepS \val$, we must show $\exists \expr'' . (\expr \stepS \expr'') \land (\Val{\expr''} \land \elctx[\expr''] \stepS \val)$.
  By lemma \ref*{lem:EuC}, we know $\exists \expr'' . (\expr \stepS \expr'') \land ((\Val{\expr''} \land \elctx[\expr''] \stepS \val) \lor
  (\neg \Val{\expr''} \land \elctx[\expr''] = \val))$. Now, if $\neg \Val{\expr''}$ then $\neg \Val{\elctx[\expr'']}$, which one may see simply by inspecting the possible evaluation contexts. Therefore, $\elctx[\expr''] \neq \val$, so $\neg(\neg \Val{\expr''} \land \elctx[\expr''] = \val)$. Thus, we conclude $\exists \expr'' . (\expr \stepS \expr'') \land (\Val{\expr''} \land \elctx[\expr''] \stepS \val)$.
\end{proof}

\subsection{Substitution}
We will not define formally how a substitution $\subst{\expr}{\var}{\expr'}$ works here, but refer instead to types and programming languages by benjamin c pierce (section 5.3)\todo{proper ref}, who explains how to formally define substitutions so that they are \textit{capture-avoiding}. However, we will be needing a way to close off open expressions later, so we shall define here an extended substitution $\gamma = \{\map{\var_1}{\val_1}, \map{\var_2}{\val_2}, \dots\}$ inductively as follows:
\begin{align*}
  \emptyset(\expr) &= \expr\\
  \gamma[\map{\var}{\val}](\expr) &= \gamma(\subst{\expr}{\var}{\val})
\end{align*}
The following lemma will be useful in later proofs.
\begin{lemma}[Substitution]\label{lem:sub}
  $\gamma[\map{\var}{\val}](\expr) = \subst{\gamma(\expr)}{\var}{\val}$
\end{lemma}
\begin{proof}
  Similar to Lemma 10 in \cite{DBLP:journals/corr/abs-1907-11133}.
\end{proof}

\subsection{Type Safety, Normalisation, and Determinacy}
We note here a few interesting results about System F. They will not be proved here, as it requires a substantial amount of work.\\
Firstly, System F is a type-safe language. Essentially, this means that well-typed programs don't get "stuck", in the sense that either we can take a step, or we have reduced to a value. We may state this formally as follows
\begin{theorem}\label{thm:typesafety}
  $\jdg{\emptenv}{\empvenv}{\expr}{\typ} \land \expr \stepS \expr' \implies \Val{\expr'} \lor \exists \expr'' . \expr' \step \expr''$
\end{theorem}
Secondly, every derivation of an expression in System F will at some point terminate. This property is called "normalisation".
\begin{theorem}\label{thm:norm}
  System F is a normalising language.
\end{theorem}
Together with type-safety, this implies that all closed and well-typed expressions will terminate at some value. \todo{is this correct?}
Finally, System F is a deterministic language.
\begin{theorem}\label{thm:determinacy}
  $\forall \expr, \val_1, \val_2 . \expr \Downarrow \val_1 \land \expr \Downarrow \val_2 \implies \val_1 = \val_2$
\end{theorem}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Contextual Equivalence}
\label{ch:CE}

\todo{draft}\\
Imagine you are writing a larger program, and as part of that program, you need to use a stack. So as part of your program, you implement a stack. However, your implementation is naive, and not efficient. Thus you implement a new stack, that is more complex, but also more efficient. You would of course want to use the more efficient stack implementation in your larger program, but since it is more complex, you are not really sure whether you can justify the refactoring – the implementations might show differing behaviour.\\
What you want to show, then, is that your two stack implementations \textit{behaves} the same. In other words, no matter which \textit{context} you use your two stack implementations in, they will always behave the same as part of the context. This is intuitively what we want to define with \textit{Contextual Equivalence}.\\
In this chapter we give two equivalent definitions of what it means for programs to be contextually equivalent. The first definition will be more intuitive and instructive, while the second will give a deeper insight into the theoretical underpinnings of contextual equivalence.

\section{Definition of Contextual Equivalence}
In order to define contextual equivalence, we will first need to define the notion of a context. As with the evaluation context, this will simply be a program with exactly one hole in it, which may be plugged by some expression.
\begin{definition}[Context]
  A context $\ctx$ is anything that may be derived using the following CFG.
  \begin{align*}
  \ctx \BNFdef& \empctx \ALT
                \ctx + \expr \ALT \expr + \ctx \ALT
                \ctx - \expr \ALT \expr - \ctx \ALT
                \ctx \le \expr \ALT \expr \le \ctx \ALT
                \ctx < \expr \ALT \expr < \ctx \ALT
                \ctx = \expr \ALT \expr = \ctx \ALT\\
              & {\If \ctx then \expr else \expr} \ALT
                {\If \expr then \ctx else \expr} \ALT
                {\If \expr then \expr else \ctx} \ALT
                (\ctx, \expr) \ALT (\expr, \ctx) \ALT\\
              & \Fst \ctx \ALT \Snd \ctx \ALT
                \Inj{1} \ctx \ALT \Inj{2} \ctx \ALT
                \Match \ctx with \Inj{1} \var => \expr | \Inj{2} \var => \expr end \ALT\\
              & \Match \expr with \Inj{1} \var => \ctx | \Inj{2} \var => \expr end \ALT\\
              & \Match \expr with \Inj{1} \var => \expr | \Inj{2} \var => \ctx end \ALT
              \fun \var . \ctx \ALT
              \ctx \; \expr \ALT \expr \; \ctx \ALT \Tlam \ctx \ALT \Tapp{\ctx}
  \end{align*}
\end{definition}
Unlike the evaluation context, the hole can here be \textit{anywhere} in the program. This is due to how we will be defining contextual equivalence. Intuitively, we only want to consider two expressions contextually equivalent, when we can plug them into \textit{any} program with a hole, and they elicit similar behaviour.\\
Next, we shall define "Context Typing". The type of a context will capture the type of the hole, and the type of plugged program. We define it as an inference rule:
\begin{mathpar}
  \inferrule*[lab=T-ctx]
    { {\jdg{\tenv}{\venv}{\expr}{\typ}} \and 
      {\jdg{\tenv'}{\venv'}{\ctx[\expr]}{\typ'}}}
    {\ctx : (\jdgType{\tenv}{\venv}{\typ}) \Rightarrow (\jdgType{\tenv'}{\venv'}{\typ'})}
\end{mathpar}
We can read this as: the context $\ctx$ takes an expression $\expr$ (the expression which plugs the hole) of type $\typ$ under $\tenv, \venv$, and outputs an expression $\ctx[\expr]$ (the plugged program) of type $\typ'$ under $\tenv', \venv'$.\\
With this defined, we are now ready to define contextual equivalence. We first state the definition, and then give some intuition as to why this definition makes sense. 
\begin{definition}[Contextual Equivalence]\label{def:CE}
  We define contextual equivalence of two expressions $\expr_1$ and $\expr_2$ at type $\typ$ under $\tenv$ and $\venv$ as
  \begin{equation*}
    \begin{gathered}
      \ctxRel{\tenv}{\venv}{\expr_1}{\expr_2}{\typ}\\
      \iff\\
      \jdg{\tenv}{\venv}{\expr_1}{\typ} \quad \land \quad
      \jdg{\tenv}{\venv}{\expr_2}{\typ} \quad \land \quad\\
      \forall \ctx : (\jdgType{\tenv}{\venv}{\typ}) \Rightarrow (\jdgType{\emptenv}{\empvenv}{\Tbool}), \val . (\ctx[\expr_1] \Downarrow \val \iff \ctx[\expr_2] \Downarrow \val)
    \end{gathered}
  \end{equation*}
\end{definition}
This says that two expressions are contextually equivalent when they are well typed and we can plug them into any context, which closes both expressions and makes the plugged programs have type $\Tbool$, and the plugged programs run down to the same value (thus, either $\True$ or $\False$). In other words, given two programs, $\expr_1$, $\expr_2$ that are contextually equivalent, if we plug them into any context, $\ctx$, which becomes closed and of type $\Tbool$, then one program, $\ctx[\expr_1]$ terminates to some Boolean $\val$ if and only if the other program $\ctx[\expr_2]$ terminates to the same Boolean, $\val$.\\
To help demystify this definition, we will discuss a few points. Firstly, why we have decided to use $\Tbool$ as the type of the plugged programs; there are plenty other types that could have been used instead such as $\Tunit$ or $\Tint$. Why not use those? The answer is that using $\Tbool$ is "strong enough". We will discuss what this means in a moment. But we could in fact have used some other type like $\Tint$ or even a composite type like $\Tprod{\Tbool}{\Tint}$. The important part is that we are able to make the plugged programs elicit differing behaviour. We cannot do this if the plugged programs have type $\Tunit$; by theorem \ref{thm:typesafety} and \ref{thm:norm} we know that both plugged programs terminate at a value \todo{is this correct?}, and there is only one value with type $\Tunit$, namely $\TT$, so both programs will terminate at $\TT$ regardless of what $\expr_1$ and $\expr_2$ looks like. Had we been dealing with a non-terminating language, then we could have used $\Tunit$, since it would then have two possible differing behaviours: terminate with $\TT$, or not terminate. In that case, we would define contextual equivalence as $\ctx[\expr_1] \Downarrow \iff \ctx[\expr_2] \Downarrow$.

Now, let's discuss why our definition is strong enough, and what that even means. If $\expr_1$ and $\expr_2$ run down to some values, then those values should be behaviourally the same. If they are of integer type, for example, then intuitively, the two values should be the same number. And for product types, this means that the first value in each pair should be behaviourally the same, and likewise with the second value in each pair. Our definition of contextual equivalence ensures this. To see why this is the case, consider two contextually equivalent programs $\expr_1$ and $\expr_2$, where $\jdg{\emptenv}{\empvenv}{\expr_1}{\typ}$ and $\jdg{\emptenv}{\empvenv}{\expr_2}{\typ}$.
Now consider what happens if $\expr_1$ terminates with some value $\val_1$. Can we then guarantee that $\expr_2$ also terminates with some value $\val_2$, and $\val_1$ and $\val_2$ behave the same? Since $\expr_1$ and $\expr_2$ are contextually equivalent, then we can put them into any context, $\ctx$, and one will terminate at some value $\val$ if and only if the other one does.
Let's first consider when $\typ = \Tint$. Then consider when $\ctx$ has the form $\empctx = \val_1$. Here $\ctx[\expr_1] \Downarrow \True$. But what about $\ctx[\expr_2]$? If $\val_2 \neq \val_1$, then our evaluation rule E-not-eq tells us that $\ctx[\expr_2] \Downarrow \False$. However, since $\expr_1$ and $\expr_2$ are contextually equivalent, and $\ctx[\expr_1]$ reduces to $\True$, then we know that $\ctx[\expr_2]$ must reduce to $\True$. Hence it is not the case that $\val_2 \neq \val_1$, thus $\val_2 = \val_1$. So if our two programs of type integer are contextually equivalent, then they must both evaluate to the same number.

It becomes a little more difficult to reason about when $\typ$ is not a base-type, like $\Tunit$, $\Tint$, or $\Tbool$. Take function type, for instance. If $\expr_1$ and $\expr_2$ both evaluate down to functions, how do we know that those functions are behaviourally equivalent? To see this, consider the following "congruence" rule:
\begin{mathpar}
  \inferrule*[lab=Cng-ctx-app]
  { { \ctxRel{\tenv}{\venv}{f}{f'}{\Tfunc{\typ}{\typ'}} } \and
    { \ctxRel{\tenv}{\venv}{t}{t'}{\typ} }
  }
  { \ctxRel{\tenv}{\venv}{f \; t}{f' \; t'}{\typ'} }
\end{mathpar}
This essentially gives us what we want: if we have two contextually equivalent functions, then, as long as we give them contextually equivalent inputs, the outputs will also be contextually equivalent. That output may be another function, but then this rule applies again to that output, and so on. In other words, we can keep on applying this rule until we at some point get a base type, like $\Tint$, and at that point, we know that the two numbers will be the same, by the argument made above.\\
Of course, it may happen that the output is of another non-base type, such as type abstraction. But we may state similar congruence rules for all other non-base types. However proving all of them is quite tedious, so we will here only prove the congruence rule for function application.
\begin{proof}
  By the two hypotheses of the rule, we know that $\jdg{\tenv}{\venv}{f}{\Tfunc{\typ}{\typ'}}$ and $\jdg{\tenv}{\venv}{t}{\typ}$. So by the T-APP rule, we may conclude $\jdg{\tenv}{\venv}{{f \; t}}{\typ'}$. Likewise for the prime variants. So all that remains to be shown is that $\forall \ctx : (\jdgType{\tenv}{\venv}{\typ'}) \Rightarrow (\jdgType{\emptenv}{\empvenv}{\Tbool}), \val . (\ctx[f \; t] \Downarrow \val \iff \ctx[f' \; t'] \Downarrow \val)$. So assume some context, $\ctx$, of the right type, and some value $\val$. Consider now the context $\ctx[\empctx \; t]$. We know that $f$ is contextually equivalent to $f'$, so $\forall \val' . \ctx[f \; t] \Downarrow \val' \iff \ctx[f' \; t] \Downarrow \val'$. Now consider the context $\ctx[f' \empctx]$. Since $t$ is contextually equivalent to $t'$, then we know $\forall \val'' . \ctx[f' \; t] \Downarrow \val'' \iff \ctx[f' \; t'] \Downarrow \val''$. Now it follows by instantiating both of the prior results with $\val$. Then we have $\ctx[f \; t] \Downarrow \val \iff \ctx[f' \; t] \Downarrow \val \iff \ctx[f' \; t'] \Downarrow \val$, which was what we wanted.
\end{proof}

The way we have defined contextual equivalence is quite instructive and intuitive. However, one may define contextual equivalence in another, equivalent way, which gives much insight into contextual equivalence, and will make working with the logical relation later more intuitive. We will explore this alternative definition in the next section.

\section{Alternative Definition of Contextual Equivalence}
Before giving the alternative definition, we first introduce a few concepts. In the following, we will be working with relations $R \subseteq \TENV \times \VENV \times \EXPR \times \EXPR \times \TYPE$, and $R$ will refer to any such relation. $\TENV$ is simply the set of all type environments, so $\tenv \in \TENV$. Likewise with the rest. We also introduce the following notation: $R(\tenv, \venv, \expr, \expr', \typ) \triangleq \jdgRel{\tenv}{\venv}{\expr}{}{\expr'}{\typ}$, and use them interchangeably.\\
Now we define two properties that a relation $R$ may have.
\begin{definition}[Adequacy]
  We say $R$ is an adequate relation when it holds for $R$ that $\jdgRel{\emptenv}{\empvenv}{\expr}{}{\expr'}{\Tbool} \implies \expr \Downarrow \val \iff \expr' \Downarrow \val$.
\end{definition}

\begin{definition}[Congruency]
  We say $R$ is a congruence relation (with respect to the typing rules) when it satisfies all the congruence rules that arises from the typing rules.
\end{definition}
For instance, the congruence rules for T-unit and T-app would be:
\begin{mathpar}
  \inferrule*[lab=Cng-unit]{ }
    {\jdgRel{\tenv}{\venv}{\TT}{}{\TT}{\Tunit}}
  \and
  \inferrule*[lab=Cng-Tapp]
    { \jdgRel{\tenv}{\venv}{\expr}{}{\expr'}{\Tall{\Tvar}{\typ}} }
    { \jdgRel{\tenv}{\venv}{\Tapp{\expr}}{}{\Tapp{\expr'}}{\subst{\typ}{\Tvar}{\typ'}} }
\end{mathpar}
The remaining congruence rules can be found in the appendix (\ref{appendix:Cng}).\\
Now, we may define contextual equivalence in the following way.
\begin{definition}\label{def:CE2}
  Contextual Equivalence is a relation, $CE \subseteq \TENV \times \VENV \times \EXPR \times \EXPR \times \TYPE$, such that
  \begin{itemize}
    \item all expressions in $CE$ are well-typed
    \item $CE$ is a congruence relation
    \item $CE$ is an adequate relation
  \end{itemize}
  Finally, it is the coarsest such relation.
\end{definition}
$CE$ being the coarsest such relation means that if given a relation $R$ satisfying the three properties, then $\forall \tenv, \venv, \expr, \expr', \typ . R(\tenv, \venv, \expr, \expr', \typ) \implies CE(\tenv, \venv, \expr, \expr', \typ)$.\\
We of course have to show that this definition of Contextual Equivalence is actually equivalent to the one given in definition \ref{def:CE}:
\begin{theorem}\label{thm:CE_eq}
  $\ctxRel{\tenv}{\venv}{\expr}{\expr'}{\typ} \iff CE(\tenv, \venv, \expr, \expr', \typ)$
\end{theorem}
We will show this in two steps, where each step essentially corresponds to one way of the double implication. Each step will be phrased as a theorem.
\begin{theorem}\label{thm:CE_eq_part1}
  $\ctxRel{\cdot}{\cdot}{\cdot}{\cdot}{\cdot} \subseteq \TENV \times \VENV \times \EXPR \times \EXPR \times \TYPE$ is a congruence relation, an adequate relation, and all expressions in the relation are well-typed.
\end{theorem}
\begin{proof}
  First, the well-typedness follows directly from the definition of contextual equivalence.\\
  Second, let's show that it is an adequate relation. So assuming $\ctxRel{\emptenv}{\empvenv}{\expr}{\expr'}{\Tbool}$, we must show $\expr \Downarrow \val \iff \expr' \Downarrow \val$. We know that $\forall \ctx : (\jdgType{\emptenv}{\empvenv}{\Tbool}) \Rightarrow (\jdgType{\emptenv}{\empvenv}{\Tbool}), \val' . (\ctx[\expr] \Downarrow \val' \iff \ctx[\expr'] \Downarrow \val')$. So specifically for $C$ being the empty context and $\val'$ being $\val$, we get $\expr \Downarrow \val \iff \expr' \Downarrow \val$, which was what we wanted.\\
  To show that it is a congruence relation, we must go through all the congruence rules, and show that they hold. We did the one for function application above, Cng-ctx-app. The rest will not be shown here.
\end{proof}

To prove the next theorem, we will need to show two lemmas.
\begin{lemma}[Reflexivity]\label{lem:R_Cng_is_reflexive}
  Let $R$ be a congruence relation. Then $\jdg{\tenv}{\venv}{\expr}{\typ} \implies R(\tenv, \venv, \expr, \expr, \typ)$.
\end{lemma}
\begin{proof}
  By induction on the typing derivation of $\expr$. It follows immediately from applying the induction hypothesis and applying congruency rules. We show one case here.
  \begin{itemize}
    \item[case] T-tlam.\\
      Assuming $\jdg{\tenv}{\venv}{\Tlam \expr}{\Tall{\Tvar}{\typ}}$ and $\jdg{\tenv, \Tvar}{\venv}{\expr}{\typ}$, we must show $R(\tenv, \venv, \Tlam \expr, \Tlam \expr, \Tall{\Tvar}{\typ})$. Our induction hypothesis is $R((\tenv, \Tvar), \venv, \expr, \expr, \typ)$ which is equivalent to $\jdgRel{\tenv, \Tvar}{\venv}{\expr}{}{\expr}{\typ}$. By the congruency rule $Cng-tlam$, we then get $\jdgRel{\tenv}{\venv}{\Tlam \expr}{}{\Tlam \expr}{\Tall{\Tvar}{\typ}}$, which was what we wanted.
  \end{itemize}
\end{proof}

\begin{lemma}\label{lem:CE_eq_part2_helper}
  Let $R$ be a congruence relation, then $R(\tenv, \venv, \expr, \expr', \typ) \; \land \; \ctx:(\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv'}{\venv'}{\typ'}) \implies R(\tenv', \venv', C[\expr], C[\expr'], \typ')$
\end{lemma}
\begin{proof}
  By induction on $\ctx$. We show here only a few interesting cases.
  For each non-base-case we show, the induction hypothesis will be $\forall \tenv, \venv, \tenv', \venv', \expr, \expr', \typ, \typ' .\\ R(\tenv, \venv, \expr, \expr', \typ) \land \ctx' : (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv'}{\venv'}{\typ'}) \implies R(\tenv', \venv', \ctx'[\expr], \ctx'[\expr'], \typ')$, where $\ctx'$ is structurally smaller than $\ctx$.
  \begin{itemize}
    \item[case] $\ctx = \empctx$.\\
      So assuming $R(\tenv, \venv, \expr, \expr', \typ)$ and $\ctx: (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv'}{\venv'}{\typ'})$, we must show $R(\tenv', \venv', \ctx[\expr], \ctx[\expr'], \typ')$. We may conclude that $\tenv = \tenv'$, $\venv = \venv'$, and $\typ = \typ'$, given that $\empctx : (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv}{\venv}{\typ})$. So since $\expr = \empctx[\expr] = \ctx[\expr]$, and $\expr' = \empctx[\expr'] = \ctx[\expr']$, we get $R(\tenv', \venv', \ctx[\expr], \ctx[\expr'], \typ')$, which was what we wanted.
    \item[case] $\ctx = \ctx' + \expr''$\\
      So assuming $R(\tenv, \venv, \expr, \expr', \typ)$ and $\ctx : (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv'}{\venv'}{\typ'})$, we must show $R(\tenv', \venv', \ctx[\expr], \ctx[\expr'], \typ')$. In this case, $\ctx : (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv'}{\venv'}{\Tint})$ and $\ctx' : (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv}{\venv}{\Tint})$, meaning $\typ' = \Tint$. So we have $R(\tenv, \venv, \expr, \expr', \Tint)$, and our goal then is $R(\tenv', \venv', \ctx[\expr], \ctx[\expr'], \Tint)$. From the context typing and from rule T-add, we may conclude $\jdg{\tenv'}{\venv'}{\expr''}{\Tint}$. So by lemma \ref{lem:R_Cng_is_reflexive}, we know that $\jdgRel{\tenv'}{\venv'}{\expr''}{}{\expr''}{\Tint}$. And by I.H. we get $R(\tenv', \venv', \ctx'[\expr], \ctx'[\expr'], \Tint) \equiv \jdgRel{\tenv'}{\venv'}{\ctx'[\expr]}{}{\ctx'[\expr']}{\Tint}$. Finally, from the congruence rule cng-add, we get $\jdgRel{\tenv'}{\venv'}{\ctx'[\expr] + \expr''}{}{\ctx'[\expr'] + \expr''}{\Tint} \equiv \jdgRel{\tenv'}{\venv'}{\ctx[\expr]}{}{\ctx[\expr']}{\Tint}$, which was what we wanted.
    \item[case] $\ctx = \Fst \ctx'$\\
      Then $\ctx : (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv'}{\venv'}{\typ_1})$ and $\ctx' : (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv'}{\venv'}{\Tprod{\typ_1}{\typ_2}})$, so our goal is $R(\tenv', \venv', \ctx[\expr], \ctx[\expr'], \typ_1)$. By I.H. we get $\jdgRel{\tenv'}{\venv'}{\ctx'[\expr]}{}{\ctx'[\expr']}{\Tprod{\typ_1}{\typ_2}}$, and by cng-fst with this, we get $\jdgRel{\tenv'}{\venv'}{\Fst \ctx'[\expr]}{}{\Fst \ctx'[\expr']}{\typ_1} \equiv \jdgRel{\tenv'}{\venv'}{\ctx[\expr]}{}{\ctx[\expr']}{\typ_1}$.
    \item[case] $\ctx = \fun \var . \ctx'$\\
      Then $\ctx : (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv'}{\venv'}{\Tfunc{\typ_1}{\typ_2}})$ and $\ctx' : (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv'}{\venv', x : \typ_1}{\typ_2})$, so our goal is $R(\tenv', \venv', \ctx[\expr], \ctx[\expr'], \Tfunc{\typ_1}{\typ_2})$. By I.H. we get $\jdgRel{\tenv'}{\venv', x : \typ_1}{\ctx'[\expr]}{}{\ctx'[\expr']}{\typ_2}$, and by cng-lam with this, we get $\jdgRel{\tenv'}{\venv'}{\fun \var . \ctx'[\expr]}{}{\fun \var . \ctx'[\expr']}{\Tfunc{\typ_1}{\typ_2}} \equiv \jdgRel{\tenv'}{\venv'}{\ctx[\expr]}{}{\ctx[\expr']}{\Tfunc{\typ_1}{\typ_2}}$.
    \item[case] $\ctx = \ctx' \; \expr''$\\
      Then $\ctx : (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv'}{\venv'}{\typ_2})$ and $\ctx' : (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv'}{\venv'}{\Tfunc{\typ_1}{\typ_2}})$, so our goal is $R(\tenv', \venv', \ctx[\expr], \ctx[\expr'], \typ_2)$. From the context-typing and T-app, we have $\jdg{\tenv'}{\venv'}{\expr''}{\typ_1}$. By lemma \ref{lem:R_Cng_is_reflexive}, we get $\jdgRel{\tenv'}{\venv'}{\expr''}{}{\expr''}{\typ_1}$. Now, by the induction hypothesis, we get $\jdgRel{\tenv'}{\venv'}{\ctx'[\expr]}{}{\ctx'[\expr']}{\Tfunc{\typ_1}{\typ_2}}$. And by cng-app with this, we get $\jdgRel{\tenv'}{\venv'}{\ctx'[\expr] \; \expr''}{}{\ctx'[\expr'] \; \expr''}{\typ_2} \equiv \jdgRel{\tenv'}{\venv'}{\ctx[\expr]}{}{\ctx[\expr]}{\typ_2}$.
    \item[case] $\ctx = \Tlam \ctx'$\\
      Then $\ctx : (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv'}{\venv'}{\Tall{\Tvar}{\typ'}})$ and $\ctx' : (\jdgType{\tenv}{\venv}{\typ} \Rightarrow \jdgType{\tenv', \Tvar}{\venv'}{\typ'})$, so our goal is $R(\tenv', \venv', \ctx[\expr], \ctx[\expr'], \Tall{\Tvar}{\typ'})$. By I.H. we get $\jdgRel{\tenv', \Tvar}{\venv'}{\ctx'[\expr]}{}{\ctx'[\expr']}{\typ'}$, and by cng-tlam with this, we get $\jdgRel{\tenv'}{\venv'}{\Tlam \ctx'[\expr]}{}{\Tlam \ctx'[\expr']}{\Tall{\Tvar}{\typ'}} \equiv \jdgRel{\tenv'}{\venv'}{\ctx[\expr]}{}{\ctx[\expr']}{\Tall{\Tvar}{\typ'}}$.
  \end{itemize}
\end{proof}
With this lemma proved, we are ready to prove the next theorem.
\begin{theorem}\label{thm:CE_eq_part2}
  Let $R$ be a relation satisfying the three properties of definition \ref{def:CE2}, then $R(\tenv, \venv, \expr, \expr', \typ) \implies \ctxRel{\tenv}{\venv}{\expr}{\expr'}{\typ}$.
\end{theorem}
\begin{proof}
  So assuming $R(\tenv, \venv, \expr, \expr', \typ)$, we must show 
  $\jdg{\tenv}{\venv}{\expr}{\typ} \; \land \; \jdg{\tenv}{\venv}{\expr'}{\typ} \; \land \forall \ctx : (\jdgType{\tenv}{\venv}{\typ}) \Rightarrow (\jdgType{\emptenv}{\empvenv}{\Tbool}), \val . (\ctx[\expr] \Downarrow \val \iff \ctx[\expr'] \Downarrow \val)$. Again, the well-typedness follows from the fact that all expressions in $R$ are well-typed. So what remains to be shown is that $\forall \ctx : (\jdgType{\tenv}{\venv}{\typ}) \Rightarrow (\jdgType{\emptenv}{\empvenv}{\Tbool}), \val . (\ctx[\expr] \Downarrow \val \iff \ctx[\expr'] \Downarrow \val)$. So assume some context $C$ of the right type and some value $\val$. By lemma \ref{lem:CE_eq_part2_helper}, we have $R(\emptenv, \empvenv, C[\expr], C[\expr'], \Tbool)$. By adequacy of $R$, we have that $\ctx[\expr] \Downarrow \val \iff \ctx[\expr'] \Downarrow \val$, which was what we wanted.
\end{proof}

Now, the proof of the two definitions of contextual equivalence being equivalent follows easily:
\begin{proof}[Proof of theorem \ref{thm:CE_eq}]
  By theorem \ref{thm:CE_eq_part1} and from the fact that $CE$ is the coarsest relation satisfying the three properties, it follows that $\ctxRel{\tenv}{\venv}{\expr}{\expr'}{\typ} \implies CE(\tenv, \venv, \expr, \expr', \typ)$.\\
  By theorem \ref{thm:CE_eq_part2} and from the fact that $CE$ is one such relation $R$, it follows that $CE(\tenv, \venv, \expr, \expr', \typ) \implies \ctxRel{\tenv}{\venv}{\expr}{\expr'}{\typ}$.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Logical Relations Model for Contextual Equivalence}
\label{ch:LR}

\todo{draft}
\section{Logical Relations}
\todo{explain briefly what logical relations are}

\section{Defining the Logical Relations Model}
well-typedness relation
\begin{equation*}
  \WtInpGen{\typ}{\rho} \triangleq \jdg{\emptenv}{\empvenv}{\val_1}{\rho_1(\typ)} \land \jdg{\emptenv}{\empvenv}{\val_2}{\rho_2(\typ)}\\
\end{equation*}
Value interpretation
As part of all relations below, we have that $\WtInpGen{\typ}{\rho}$, which we don't write for succinctness.
\begin{align*}
  \ValInpGen{\Tunit}{\rho}  &\triangleq (\val_1, \val_2) \in \{(\TT, \TT)\}\\
  \ValInpGen{\Tint}{\rho}   &\triangleq (\val_1, \val_2) \in \{(\Num{n}, \Num{n}) \mid \Num{n} \in \Tint\}\\
  \ValInpGen{\Tbool}{\rho}  &\triangleq (\val_1, \val_2) \in \{(\True, \True), (\False, \False)\}\\
  \ValInpGen{\Tprod{\typ_1}{\typ_2}}{\rho}  &\triangleq (\val_1, \val_2) \in \{((\valB_{11}, \valB_{12}), (\valB_{21}, \valB_{22})) \mid \ValInp{\typ_1}{\rho}(\valB_{11}, \valB_{21}) \land \ValInp{\typ_2}{\rho}(\valB_{12}, \valB_{22})\}\\
  \ValInpGen{\Tsum{\typ_1}{\typ_2}}{\rho}   &\triangleq 
  \begin{aligned}[t]
    (\val_1, \val_2) \in \{(\Inj{1} \valB_1, \Inj{1} \valB_2) \mid \ValInp{\typ_1}{\rho}(\valB_1, \valB_2)\} \lor \\
    (\val_1, \val_2) \in \{(\Inj{2} \valB_1, \Inj{2} \valB_2) \mid \ValInp{\typ_2}{\rho}(\valB_1, \valB_2)\}
  \end{aligned}\\
  \ValInpGen{\Tfunc{\typ_1}{\typ_2}}{\rho}  &\triangleq 
  \begin{aligned}[t]
    (\val_1, \val_2) \in \{(\fun \var . \expr_1, \fun \var . \expr_2) \mid \forall \valB_1, \valB_2 . \ValInp{\typ_1}{\rho}(\valB_{1}, \valB_{2}) \implies\\
    \ExpInp{\typ_2}{\rho}(\subst{\expr_1}{\var}{\valB_1}, \subst{\expr_2}{\var}{\valB_2})\}
  \end{aligned}\\
  \ValInpGen{\Tall{\Tvar}{\typ}}{\rho}  &\triangleq 
  \begin{aligned}[t]
    (\val_1, \val_2) \in \{(\Tlam \expr_1, \Tlam \expr_2) \mid \forall \typ_1, \typ_2, R \in Rel[\typ_1, \typ_2] .\\
    \ExpInp{\typ}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]}(\expr_1, \expr_2)\}
  \end{aligned}\\
  \ValInpGen{\Tvar}{\rho} &\triangleq (\val_1, \val_2) \in \rho_R[\Tvar]\\
\end{align*}

Relational substitution
\begin{align*}
  Rel[\typ_1, \typ_2] \triangleq 
  \left\{R \; \middle\vert \;
  \begin{aligned}
    R \in \mathcal{P}(Val \times Val) \land \jdgType{\emptenv}{\empvenv}{\typ_1} \land \jdgType{\emptenv}{\empvenv}{\typ_2} \land\\ \forall (\val_1, \val_2) \in R . \jdg{\emptenv}{\empvenv}{\val_1}{\typ_1} \land \jdg{\emptenv}{\empvenv}{\val_2}{\typ_2}
  \end{aligned}
  \right\}
\end{align*}

Expression interpretation
\begin{multline*}
  \ExpInp{\typ}{\rho}(\expr_1, \expr_2) \triangleq
    \jdg{\emptenv}{\empvenv}{\expr_1}{\rho_1(\typ)} \land \jdg{\emptenv}{\empvenv}{\expr_2}{\rho_2(\typ)} \land\\
    (\exists \val_1, \val_2 . \expr_1 \stepS \val_1 \land \expr_2 \stepS \val_2 \land\ValInpGen{\typ}{\rho})
\end{multline*}

Variable environment interpretation
\begin{align*}
  \VenvInp{\empvenv}{\rho} &\triangleq \{ \emptyset \}\\
  \VenvInp{\venv, \var : \typ}{\rho} &\triangleq \{\gamma[\map{\var}{(\val_1, \val_2)}] \mid \gamma \in \VenvInp{\venv}{\rho} \land \ValInpGen{\typ}{\rho}\}
\end{align*}

Type environment interpretation
\begin{align*}
  \TenvInp{\emptenv} &\triangleq \{ \emptyset \}\\
  \TenvInp{\tenv, \Tvar} &\triangleq \{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}] \mid \rho \in \TenvInp{\tenv} \land R \in Rel[\typ_1, \typ_2]\}
\end{align*}

\begin{definition}[Logical relation]\label{def:LogRel}
  \begin{equation*}
    \begin{gathered}
      \LogRel{\tenv}{\venv}{\expr}{\expr'}{\typ}\\
      \iff\\
      \jdg{\tenv}{\venv}{\expr}{\typ} \; \land \; \jdg{\tenv}{\venv}{\expr'}{\typ} \; \land\\
      \forall \rho \in \TenvInp{\tenv}, \gamma \in \VenvInp{\venv}{\rho} . 
      \ExpInp{\typ}{\rho}(\gamma_1(\expr), \gamma_2(\expr'))
    \end{gathered}
  \end{equation*}
\end{definition}

\section{Compatibility lemmas}
Essentially just congruency rules as stated in appendix (but with LR being the relation). We have to prove these (and adequacy) to show that LR ==> CE, meaning we can state theorems in terms of LR instead of CE, and then get CE as a consequence.
\begin{lemma}[Cmpt-unit]
  $\inferrule{ }{\LogRel{\tenv}{\venv}{\TT}{\TT}{\Tunit}}$
\end{lemma}
\begin{proof}
  By definition \ref*{def:LogRel}, we must show $\jdg{\tenv}{\venv}{\TT}{\Tunit} \land \jdg{\tenv}{\venv}{\TT}{\Tunit} \land\\ \forall \rho \in \TenvInp{\tenv}, \gamma \in \VenvInp{\venv}{\rho} . 
  \ExpInp{\Tunit}{\rho}(\gamma_1(\TT), \gamma_2(\TT))$. The well-typedness simply follows by the typing rule T-unit.
  So assume some $\rho \in \TenvInp{\tenv}$ and $\gamma \in \VenvInp{\venv}{\rho}$, we must show $\ExpInp{\Tunit}{\rho}(\gamma_1(\TT), \gamma_2(\TT)) \equiv \ExpInp{\Tunit}{\rho}(\TT, \TT)$. Thus, we must show three things
  \begin{enumerate}
    \item $\jdg{\emptenv}{\empvenv}{\TT}{\rho_1(\Tunit)}$
    \item $\jdg{\emptenv}{\empvenv}{\TT}{\rho_2(\Tunit)}$
    \item $\exists \val_1, \val_2 . \TT \stepS \val_1 \land \TT \stepS \val_2 \land \ValInp{\Tunit}{\rho}(\val_1, \val_2)$
  \end{enumerate}
  Given that $\rho_1(\Tunit) = \rho_2(\Tunit) = \Tunit$, the well-typedness once again simply follows from typing rule T-unit. For (3), we choose $\TT$ for $\val_1$ and $\val_2$. Then we must show $\TT \stepS \TT \land \TT \stepS \TT \land \ValInp{\Tunit}{\rho}(\TT, \TT)$. The first two holds trivially. The last part says we must show $\WtInp{\Tunit}{\rho}(\TT, \TT) \land (\TT, \TT) \in \{(\TT, \TT)\}$. The last part trivially holds, and the first part holds by the same argument made above: $\rho_1(\Tunit) = \rho_2(\Tunit) = \Tunit$, and then it follows from T-unit. 
\end{proof}


\begin{lemma}[Cmpt-add]
  $\inferrule
    { {\LogRel{\tenv}{\venv}{\expr_1}{\expr_1'}{\Tint}} \and
      {\LogRel{\tenv}{\venv}{\expr_2}{\expr_2'}{\Tint}} }
    {\LogRel{\tenv}{\venv}{\expr_1 + \expr_2}{\expr_1' + \expr_2'}{\Tint}}$
\end{lemma}
\begin{proof}
  So assuming
  \begin{align}
    &\LogRel{\tenv}{\venv}{\expr_1}{\expr_1'}{\Tint}\label{cmpt-add:1}\\
    &\LogRel{\tenv}{\venv}{\expr_2}{\expr_2'}{\Tint}\label{cmpt-add:2}
  \end{align}
  we must show $\jdg{\tenv}{\venv}{\expr_1 + \expr_2}{\Tint} \land \jdg{\tenv}{\venv}{\expr_1' + \expr_2'}{\Tint} \land \forall \rho \in \TenvInp{\tenv}, \gamma \in \VenvInp{\venv}{\rho} . 
  \ExpInp{\Tint}{\rho}(\gamma_1(\expr_1 + \expr_2), \gamma_2(\expr_1' + \expr_2'))$. From (\ref*{cmpt-add:1}), we have $\jdg{\tenv}{\venv}{\expr_1}{\Tint}$, and from (\ref*{cmpt-add:2}) we have $\jdg{\tenv}{\venv}{\expr_2}{\Tint}$. So by the T-add rule, we get $\jdg{\tenv}{\venv}{\expr_1 + \expr_2}{\Tint}$. The well-typedness of $\expr_1' + \expr_2'$ follows in the same way.\\
  So let's assume some $\rho \in \TenvInp{\tenv}$ and $\gamma \in \VenvInp{\venv}{\rho}$. We must show $\ExpInp{\Tint}{\rho}(\gamma_1(\expr_1 + \expr_2), \gamma_2(\expr_1' + \expr_2'))$, which is equivalent to $\ExpInp{\Tint}{\rho}(\gamma_1(\expr_1) + \gamma_1(\expr_2), \gamma_2(\expr_1') + \gamma_2(\expr_2'))$. Unfolding the expression interpretation, what we need to show is the following three points
  \begin{enumerate}
    \item $\jdg{\emptenv}{\empvenv}{\gamma_1(\expr_1) + \gamma_1(\expr_2)}{\rho_1(\Tint)}$
    \item $\jdg{\emptenv}{\empvenv}{\gamma_2(\expr_1') + \gamma_2(\expr_2')}{\rho_2(\Tint)}$
    \item $\exists \val_1, \val_2 . \gamma_1(\expr_1) + \gamma_1(\expr_2) \stepS \val_1 \land \gamma_2(\expr_1') + \gamma_2(\expr_2') \stepS \val_2 \land \ValInp{\Tint}{\rho}(\val_1, \val_2)$
  \end{enumerate}
  To prove these points, we will need some more information. From the last part of (\ref*{cmpt-add:1}) instantiated with $\rho$ and $\gamma$, we get
  \begin{align}
    &\jdg{\emptenv}{\empvenv}{\gamma_1(\expr_1)}{\rho_1(\Tint)}\label{cmpt-add:1.1}\\
    &\jdg{\emptenv}{\empvenv}{\gamma_2(\expr_1')}{\rho_2(\Tint)}\label{cmpt-add:1.2}\\
    &\exists \val_1, \val_2 . \gamma_1(\expr_1) \stepS \val_1 \land \gamma_2(\expr_1') \stepS \val_2 \land \ValInp{\Tint}{\rho}(\val_1, \val_2)\label{cmpt-add:1.3}
  \end{align}
  Likewise, from the last part of \ref*{cmpt-add:2} instantiated with $\rho$ and $\gamma$, we get
  \begin{align}
    &\jdg{\emptenv}{\empvenv}{\gamma_1(\expr_2)}{\rho_1(\Tint)}\label{cmpt-add:2.1}\\
    &\jdg{\emptenv}{\empvenv}{\gamma_2(\expr_2')}{\rho_2(\Tint)}\label{cmpt-add:2.2}\\
    &\exists \val_1, \val_2 . \gamma_1(\expr_2) \stepS \val_1 \land \gamma_2(\expr_2') \stepS \val_2 \land \ValInp{\Tint}{\rho}(\val_1, \val_2)\label{cmpt-add:2.3}
  \end{align}
  Now to prove the three points above. Given that $\Tint$ is a closed type, $\rho_1(\Tint) = \rho_2(\Tint) = \Tint$. Thus, point 1 follows from (\ref*{cmpt-add:1.1}), (\ref*{cmpt-add:2.1}), and the T-add rule. Similarly, point 2 follows from (\ref*{cmpt-add:1.2}), (\ref*{cmpt-add:2.2}) and the T-add rule.\\
  So all that remains to be shown is point 3. Let's denote the values in (\ref*{cmpt-add:1.3}) $\val_1'$ and $\val_2'$, and the values in (\ref*{cmpt-add:2.3}) $\val_1''$ and $\val_2''$. Then we know
  \begin{align}
    &\gamma_1(\expr_1) + \gamma_1(\expr_2) \stepS \val_1' + \gamma_1(\expr_2) \stepS \val_1' + \val_1''\label{cmpt-add:3.1}\\
    &\gamma_2(\expr_1') + \gamma_2(\expr_2') \stepS \val_2' + \gamma_2(\expr_2') \stepS \val_2' + \val_2''\label{cmpt-add:3.2}\\
    &\ValInp{\Tint}{\rho}(\val_1', \val_2') \land \ValInp{\Tint}{\rho}(\val_1'', \val_2'')\label{cmpt-add:3.3}
  \end{align}
  From (\ref*{cmpt-add:3.3}), we know that all our values are integers and $\Num{\val_1'} = \Num{\val_2'}$, and $\Num{\val_1''} = \Num{\val_2''}$. Furthermore
  $\Num{\val_1'} + \Num{\val_1''} \step \Num{\val_1' + \val_1''}$, and $\Num{\val_2'} + \Num{\val_2''} \step \Num{\val_2' + \val_2''}$. Thus $\gamma_1(\expr_1) + \gamma_1(\expr_2) \stepS \Num{\val_1' + \val_1''}$ and $\gamma_2(\expr_1') + \gamma_2(\expr_2') \stepS \Num{\val_2' + \val_2''}$.\\
  What we need to show is point 3. So now use $\Num{\val_1' + \val_1''}$ for $\val_1$, and $\Num{\val_2' + \val_2''}$ for $\val_2$. The first two propositions hold by what we have just shown, so all that remains is to show $\ValInp{\Tint}{\rho}(\Num{\val_1' + \val_1''}, \Num{\val_2' + \val_2''})$, which by definition means we have to show $\WtInp{\Tint}{\rho}(\Num{\val_1' + \val_1''}, \Num{\val_2' + \val_2''})$ and $\Num{\val_1' + \val_1''} = \Num{\val_2' + \val_2''}$. The first part follows simply from the T-int rule. For the second part, note that we know $\Num{\val_1'} = \Num{\val_2'}$, and $\Num{\val_1''} = \Num{\val_2''}$, so it follows that $\Num{\val_1' + \val_1''} = \Num{\val_2' + \val_1''} = \Num{\val_2' + \val_2''}$.
\end{proof}

\begin{lemma}[Cmpt-fst]
  $\inferrule
  { \LogRel{\tenv}{\venv}{\expr}{\expr'}{\Tprod{\typ_1}{\typ_2}} }
  { \LogRel{\tenv}{\venv}{\Fst \expr}{\Fst \expr'}{\typ_1} }$
\end{lemma}
\begin{proof}
  So assuming $\LogRel{\tenv}{\venv}{\expr}{\expr'}{\Tsum{\typ_1}{\typ_2}}$, we must show (ignoring well-typedness): $\forall \rho \in \TenvInp{\tenv}, \gamma \in \VenvInp{\venv}{\rho} . \ExpInp{\typ_1}{\rho}(\gamma_1(\Fst \expr), \gamma_2(\Fst \expr'))$. So assume some $\rho \in \TenvInp{\tenv}$, and $\gamma \in \VenvInp{\venv}{\rho}$, we must show $\ExpInp{\typ_1}{\rho}(\gamma_1(\Fst \expr), \gamma_2(\Fst \expr')) \equiv \ExpInp{\typ_1}{\rho}(\Fst \gamma_1(\expr), \Fst \gamma_2(\expr'))$. By definition of our expression interpretation, we must show
  \begin{equation}\label{cmpt-fst:goal}
    \exists \val_1, \val_2 . \Fst \gamma_1(\expr) \stepS \val_1 \land \Fst \gamma_2(\expr') \stepS \val_2 \land \ValInp{\typ_1}{\rho}(\val_1, \val_2)
  \end{equation}
  Note first that if we instantiate our initial assumption with $\rho$ and $\gamma$, we get
  \begin{align}
    &\exists \val_1, \val_2 . \gamma_1(\expr) \stepS \val_1 \land \gamma_2(\expr') \stepS \val_2 \land \ValInp{\Tprod{\typ_1}{\typ_2}}{\rho}(\val_1, \val_2)\label{cmpt-fst:1}
  \end{align}
  Let's instantiate the values in (\ref*{cmpt-fst:1}) as $\val_1'$ and $\val_2'$. Then we know
  \begin{align}
    &\Fst \gamma_1(\expr) \stepS \Fst \val_1'\label{cmpt-fst:2.1}\\
    &\Fst \gamma_2(\expr') \stepS \Fst \val_2'\label{cmpt-fst:2.2}\\
    &\ValInp{\Tprod{\typ_1}{\typ_2}}{\rho}(\val_1', \val_2')\label{cmpt-fst:2.3}
  \end{align}
  By (\ref*{cmpt-fst:2.3}) we know that $\val_1' = (\valB_{11}, \valB_{12})$ and $\val_2' = (\valB_{21}, \valB_{22})$ for some values $\valB_{11}, \valB_{12}, \valB_{21}, \valB_{22}$. Further, $\ValInp{\typ_1}{\rho}(\valB_{11}, \valB_{21})$ and $\ValInp{\typ_2}{\rho}(\valB_{12}, \valB_{22})$. Now, by (\ref*{cmpt-fst:2.1}) and E-fst we have $\Fst \gamma_1(\expr) \stepS \valB_{11}$. Likewise, from (\ref*{cmpt-fst:2.2}) and E-fst, we get $\Fst \gamma_2(\expr') \stepS \valB_{21}$.\\
  Now to prove the goal (\ref*{cmpt-fst:goal}). We take $\valB_{11}$ for $\val_1$ and $\valB_{21}$ for $\val_2$, so that we must show $ \Fst \gamma_1(\expr) \stepS \valB_{11} \land \Fst \gamma_2(\expr') \stepS \valB_{21} \land \ValInp{\typ_1}{\rho}(\valB_{11}, \valB_{21})$, all of which we have just argued holds.
\end{proof}


\begin{lemma}[Cmpt-match]\ \\
  $\inferrule
  { {\LogRel{\tenv}{\venv}{\expr_1}{\expr_1'}{\Tsum{\typ_1}{\typ_2}} } \and
  { \LogRel{\tenv}{\venv, \var : \typ_1}{\expr_2}{\expr_2'}{\typ} } \and
  { \LogRel{\tenv}{\venv, \var : \typ_2}{\expr_3}{\expr_3'}{\typ} }
  }
  { \LogRel{\tenv}{\venv}{\Match \expr_1 with \Inj{1} \var => \expr_2 | \Inj{2} \var => \expr_3 end}{\Match \expr_1' with \Inj{1} \var => \expr_2' | \Inj{2} \var => \expr_3' end}{\typ} }$
\end{lemma}
\begin{proof}
  First, we introduce the following notation: $\expr = \Match \expr_1 with \Inj{1} \var => \expr_2 | \Inj{2} \var => \expr_3 end$, and $\expr' = \Match \expr_1' with \Inj{1} \var => \expr_2' | \Inj{2} \var => \expr_3' end$.
  So we assume
  \begin{align}
    &\LogRel{\tenv}{\venv}{\expr_1}{\expr_1'}{\Tsum{\typ_1}{\typ_2}}\label{cmpt-match:1}\\
    &\LogRel{\tenv}{\venv, \var : \typ_1}{\expr_2}{\expr_2'}{\typ}\label{cmpt-match:2}\\
    &\LogRel{\tenv}{\venv, \var : \typ_2}{\expr_3}{\expr_3'}{\typ}\label{cmpt-match:3}
  \end{align}
  and must show (ignoring well-typedness) $\forall \rho \in \TenvInp{\tenv}, \gamma \in \VenvInp{\venv}{\rho} . \ExpInp{\typ}{\rho}(\gamma_1(\expr), \gamma_2(\expr'))$. So assume some $\rho \in \TenvInp{\tenv}$, and $\gamma \in \VenvInp{\venv}{\rho}$, then we must show $\ExpInp{\typ}{\rho}(\gamma_1(\expr), \gamma_2(\expr'))$. We again introduce the following notation $f = \Match \gamma_1(\expr_1) with \Inj{1} \var => \gamma_1(\expr_2) | \Inj{2} \var => \gamma_1(\expr_3) end$, and $f' = \Match \gamma_2(\expr_1') with \Inj{1} \var => \gamma_2(\expr_2') | \Inj{2} \var => \gamma_2(\expr_3') end$, and note that $\gamma_1(\expr) = f$ and $\gamma_2(\expr') = f'$. Thus, we must show: $\ExpInp{\typ}{\rho}(f, f')$, which by definition corresponds to showing
  \begin{equation}\label{cmpt-match:goal}
    \exists \val_1, \val_2 . f \stepS \val_1 \land f' \stepS \val_2 \land \ValInp{\typ}{\rho}(\val_1, \val_2)
  \end{equation}
  By \ref{cmpt-match:1} instantiated with $\rho, \gamma$, we get
  \begin{align}
    &\exists \val_1, \val_2 . \gamma_1(\expr_1) \stepS \val_1 \land \gamma_2(\expr'_1) \stepS \val_2 \land \ValInp{\Tsum{\typ_1}{\typ_2}}{\rho}(\val_1, \val_2)\label{cmpt-match:1.1}
  \end{align}
  Let's instantiate the values in (\ref*{cmpt-match:1.1}) as $\val'_{1_1}$ and $\val'_{1_2}$, so that we know $\gamma_1(\expr_1) \stepS \val'_{1_1} \land \gamma_2(\expr'_1) \stepS \val'_{1_2} \land \ValInp{\Tsum{\typ_1}{\typ_2}}{\rho}(\val'_{1_1}, \val'_{1_2})$. By definition of the value interpretation, this gives us\\
  $(\val'_{1_1}, \val'_{1_2}) \in \{(\Inj{1} \valB_1, \Inj{1} \valB_2) \mid \ValInp{\typ_1}{\rho}(\valB_1, \valB_2)\} \lor
  (\val'_{1_1}, \val'_{1_2}) \in \{(\Inj{2} \valB_1, \Inj{2} \valB_2) \mid \ValInp{\typ_2}{\rho}(\valB_1, \valB_2)\}$. We do case distinction on the "$\lor$", but show only the first case as they are similar. So assume 
  $(\val'_{1_1}, \val'_{1_2}) \in \{(\Inj{1} \valB_1, \Inj{1} \valB_2) \mid \ValInp{\typ_1}{\rho}(\valB_1, \valB_2)\}$. This means that $\val'_{1_1} = \Inj{1} \valB_1$ and $\val'_{1_2} = \Inj{1} \valB_2$ for some $\valB_1, \valB_2$, and $\ValInp{\typ_1}{\rho}(\valB_1, \valB_2)$.
  Now, from \ref{cmpt-match:2} instantiated with $\rho, \gamma' = \gamma[\map{\var}{(\valB_1, \valB_2)}]$ we get
  \begin{align}
    &\exists \val_1, \val_2 . \gamma'_1(\expr_2) \stepS \val_1 \land \gamma'_2(\expr'_2) \stepS \val_2 \land \ValInp{\typ}{\rho}(\val_1, \val_2)\label{cmpt-match:2.1}
  \end{align}
  If we instantiate the values in (\ref*{cmpt-match:2.1}) as $\val'_{2_1}$ and $\val'_{2_2}$, then we know that $\gamma'_1(\expr_2) \stepS \val'_{2_1} \land \gamma'_2(\expr'_2) \stepS \val'_{2_2} \land \ValInp{\typ}{\rho}(\val'_{2_1}, \val'_{2_2})$. By the substitution lemma (lemma \ref{lem:sub}), we then know:
  \begin{align}
    &\subst{\gamma_1(\expr_2)}{\var}{\valB_1} \stepS \val'_{2_1}\label{cmpt-match:sub.1}\\
    &\subst{\gamma_2(\expr'_2)}{\var}{\valB_2} \stepS \val'_{2_2}\label{cmpt-match:sub.2}
  \end{align}
  Now let us turn to proving the goal, (\ref*{cmpt-match:goal}). We use $\val'_{2_1}$ for $\val_1$ and $\val'_{2_2}$ for $\val_2$. Thus, we must show 
  $f \stepS \val'_{2_1} \land f' \stepS \val'_{2_2} \land \ValInp{\typ}{\rho}(\val'_{2_1}, \val'_{2_2})$. We have the following derivations:\\
  $f \stepS \Match \Inj{1} \valB_1 with \Inj{1} \var => \gamma_1(\expr_2) | \Inj{2} \var => \gamma_1(\expr_3) end \step \subst{\gamma_1(\expr_2)}{\var}{\valB_1} \stepS \val'_{2_1}$, and\\
  $f' \stepS \Match \Inj{1} \valB_2 with \Inj{1} \var => \gamma_2(\expr'_2) | \Inj{2} \var => \gamma_2(\expr'_3) end \step \subst{\gamma_2(\expr'_2)}{\var}{\valB_2} \stepS \val'_{2_2}$.\\
  In both derivations, the first "$\stepS$" follows from the instantiation of (\ref*{cmpt-match:1.1}), and the fact that $\val'_{1_1} = \Inj{1} \valB_1$ and $\val'_{1_2} = \Inj{1} \valB_2$. The next "$\step$" holds by E-match-inj1. And finally, the last "$\stepS$" holds by (\ref*{cmpt-match:sub.1}) and (\ref*{cmpt-match:sub.2}).
  Thus the first two parts of the goal are satisfied. The last part of the goal we get from the instantiation of (\ref*{cmpt-match:2.1}).
\end{proof}


\begin{lemma}[Cmpt-lam]
  $\inferrule
  { \LogRel{\tenv}{\venv, x : \typ_1}{\expr}{\expr'}{\typ_2} }
  { \LogRel{\tenv}{\venv}{\fun \var . \expr}{\fun \var . \expr'}{\Tfunc{\typ_1}{\typ_2}} }$
\end{lemma}
\begin{proof}
  So assuming 
  \begin{equation}\label{cmpt-lam:1}
    \LogRel{\tenv}{\venv, x : \typ_1}{\expr}{\expr'}{\typ_2}
  \end{equation}
  we must show (ignoring well-typedness) $\forall \rho \in \TenvInp{\tenv}, \gamma \in \VenvInp{\venv}{\rho} . \ExpInp{\Tfunc{\typ_1}{\typ_2}}{\rho}(\gamma_1(\fun \var . \expr), \gamma_2(\fun \var . \expr'))$. So assume some $\rho \in \TenvInp{\tenv}$, and $\gamma \in \VenvInp{\venv}{\rho}$, then we must show $\ExpInp{\Tfunc{\typ_1}{\typ_2}}{\rho}(\gamma_1(\fun \var . \expr), \gamma_2(\fun \var . \expr')) \equiv \ExpInp{\Tfunc{\typ_1}{\typ_2}}{\rho}(\fun \var . \gamma_1(\expr), \fun \var . \gamma_2(\expr'))$, which by definition corresponds to
  \begin{equation}\label{cmpt-lam:goal}
    \exists \val_1, \val_2 . \fun \var . \gamma_1(\expr) \stepS \val_1 \land \fun \var . \gamma_2(\expr') \stepS \val_2 \land \ValInp{\Tfunc{\typ_1}{\typ_2}}{\rho}(\val_1, \val_2)
  \end{equation}
  Since $\fun \var . \gamma_1(\expr)$ and $\fun \var . \gamma_2(\expr')$ are already values, we can use these for $\val_1$ and $\val_2$. The first two parts are then trivially satisfied, so we only need to show $\ValInp{\Tfunc{\typ_1}{\typ_2}}{\rho}(\fun \var . \gamma_1(\expr), \fun \var . \gamma_2(\expr'))$, which by definition means we have to show $\forall \valB_1, \valB_2 . \ValInp{\typ_1}{\rho}(\valB_{1}, \valB_{2}) \implies
  \ExpInp{\typ_2}{\rho}(\subst{\gamma_1(\expr)}{\var}{\valB_1}, \subst{\gamma_2(\expr')}{\var}{\valB_2})$. So assume some $\valB_1$, $\valB_2$ such that $\ValInp{\typ_1}{\rho}(\valB_{1}, \valB_{2})$, then we must show $\ExpInp{\typ_2}{\rho}(\subst{\gamma_1(\expr)}{\var}{\valB_1}, \subst{\gamma_2(\expr')}{\var}{\valB_2})$, which by definition means we have to show 
  $\exists \val_1, \val_2 . \subst{\gamma_1(\expr)}{\var}{\valB_1} \stepS \val_1 \land \subst{\gamma_2(\expr')}{\var}{\valB_2} \stepS \val_2 \land \ValInp{\typ_2}{\rho}(\val_1, \val_2)$. Now we instantiate (\ref*{cmpt-lam:1}) with $\rho, \gamma' = \gamma[\map{\var}{(\valB_1, \valB_2)}]$, so that we have
  $\exists \val_1, \val_2 . \gamma'_1(\expr) \stepS \val_1 \land \gamma'_2(\expr') \stepS \val_2 \land \ValInp{\typ_2}{\rho}(\val_1, \val_2)$. By the substitution lemma (lemma \ref*{lem:sub}), this is equivalent to our goal, so we are done.
  \todo{Prettify proof}
\end{proof}


\begin{lemma}[Cmpt-app]
  $\inferrule
  { {\LogRel{\tenv}{\venv}{\expr_1}{\expr_1'}{\Tfunc{\typ_1}{\typ_2}} } \and
  { \LogRel{\tenv}{\venv}{\expr_2}{\expr_2'}{\typ_1} } }
  { \LogRel{\tenv}{\venv}{\expr_1 \; \expr_2}{\expr_1' \; \expr_2'}{\typ_2} }$
\end{lemma}
\begin{proof}
  So we assume
  \begin{align}
    &\LogRel{\tenv}{\venv}{\expr_1}{\expr_1'}{\Tfunc{\typ_1}{\typ_2}}\label{cmpt-app:1}\\
    &\LogRel{\tenv}{\venv}{\expr_2}{\expr_2'}{\typ_1}\label{cmpt-app:2}
  \end{align}
  Then we must show $\forall \rho \in \TenvInp{\tenv}, \gamma \in \VenvInp{\venv}{\rho} . \ExpInp{\typ_2}{\rho}(\gamma_1(\expr_1 \; \expr_2), \gamma_2(\expr_1' \; \expr_2'))$. So we assume some $\rho \in \TenvInp{\tenv}, \gamma \in \VenvInp{\venv}{\rho}$, and our goal now is $\ExpInp{\typ_2}{\rho}(\gamma_1(\expr_1 \; \expr_2), \gamma_2(\expr_1' \; \expr_2')) \equiv \ExpInp{\typ_2}{\rho}(\gamma_1(\expr_1) \; \gamma_1(\expr_2), \gamma_2(\expr_1') \; \gamma_2(\expr_2'))$, which by definition means we have to show
  \begin{equation}\label{cmpt-app:goal}
    \exists \val_1, \val_2 . \gamma_1(\expr_1) \; \gamma_1(\expr_2) \stepS \val_1 \land \gamma_2(\expr_1') \; \gamma_2(\expr_2') \stepS \val_2 \land \ValInp{\typ_2}{\rho}(\val_1, \val_2)
  \end{equation}
  We instantiate both (\ref*{cmpt-app:1}) and (\ref*{cmpt-app:2}) with $\rho, \gamma$, and expand the definitions to get
  \begin{align}
    &\exists \val_1', \val_2' . \gamma_1(\expr_1) \stepS \val_1' \land \gamma_2(\expr'_1) \stepS \val_2' \land \ValInp{\Tfunc{\typ_1}{\typ_2}}{\rho}(\val_1', \val_2')\label{cmpt-app:1.1}\\
    &\exists \val_1'', \val_2'' . \gamma_1(\expr_2) \stepS \val_1'' \land \gamma_2(\expr'_2) \stepS \val_2'' \land \ValInp{\typ_1}{\rho}(\val_1'', \val_2'')\label{cmpt-app:2.1}
  \end{align}
  Instantiating all quantifications with the same name they quantify over, we get from the definition of the value interpretation for function-type that
  $\val_1' = \fun \var . \expr_1'$ and $\val_2' = \fun \var . \expr_2'$, for some $\expr_1'$ and $\expr_2'$. Further,
  \begin{equation}
    \forall \valB_1, \valB_2 . \ValInp{\typ_1}{\rho}(\valB_{1}, \valB_{2}) \implies\\
    \ExpInp{\typ_2}{\rho}(\subst{\expr_1'}{\var}{\valB_1}, \subst{\expr_2'}{\var}{\valB_2})
  \end{equation}
  We instantiate this with $\val_1''$ and $\val_2''$. The antecedent is satisfied by the last part of (\ref*{cmpt-app:2.1}), so we know $\ExpInp{\typ_2}{\rho}(\subst{\expr_1'}{\var}{\val_1''}, \subst{\expr_2'}{\var}{\val_2''})$, which by definition means
  \begin{equation}
    \exists \val_{f_1}, \val_{f_2} . \subst{\expr_1'}{\var}{\val_1''} \stepS \val_{f_1} \land \subst{\expr_2'}{\var}{\val_2''} \stepS \val_{f_2} \land \ValInp{\typ_2}{\rho}(\val_{f_1}, \val_{f_2})\label{cmpt-app:f}
  \end{equation}
  Now we turn to showing the goal, (\ref*{cmpt-app:goal}). We use $\val_{f_1}$ for $\val_1$ and $\val_{f_2}$ for $\val_2$, so that we must show:
  $\gamma_1(\expr_1) \; \gamma_1(\expr_2) \stepS \val_{f_1} \land \gamma_2(\expr_1') \; \gamma_2(\expr_2') \stepS \val_{f_2} \land \ValInp{\typ_2}{\rho}(\val_{f_1}, \val_{f_2})$. We have the following derivations:
  \begin{align}
    &\gamma_1(\expr_1) \; \gamma_1(\expr_2) \stepS \fun \var . \expr_1' \; \gamma_1(\expr_2) \stepS \fun \var . \expr_1' \; \val_1'' \step \subst{\expr_1'}{\var}{\val_1''} \stepS \val_{f_1}\label{cmpt-app:d1}\\
    &\gamma_2(\expr_1') \; \gamma_2(\expr_2') \stepS \fun \var . \expr_2' \; \gamma_2(\expr_2') \stepS \fun \var . \expr_2' \; \val_2'' \step \subst{\expr_2'}{\var}{\val_2''} \stepS \val_{f_2}\label{cmpt-app:d2}
  \end{align}
  Here, in both derivations, the first "$\stepS$" follows by (\ref*{cmpt-app:1.1}) and the fact that $\val_1' = \fun \var . \expr_1'$ and $\val_2' = \fun \var . \expr_2'$. The second "$\stepS$" follows by (\ref*{cmpt-app:2.1}). The next "$\step$" follows by rule E-lam-app, and the final "$\stepS$" follows from (\ref*{cmpt-app:f}). Thus, the first two parts of what we have to show follows from (\ref{cmpt-app:d1}) and (\ref*{cmpt-app:d2}) respectively, and the last part follows from the last part of (\ref*{cmpt-app:f}).
\end{proof}


\begin{lemma}[Cmpt-Tlam]
  $\inferrule
  { \LogRel{\tenv, \Tvar}{\venv}{\expr}{\expr'}{\typ} }
  { \LogRel{\tenv}{\venv}{\Tlam{\expr}}{\Tlam{\expr'}}{\Tall{\Tvar}{\typ}} }$
\end{lemma}
\begin{proof}
  Assuming
  \begin{equation}\label{cmpt-tlam:1}
    \LogRel{\tenv, \Tvar}{\venv}{\expr}{\expr'}{\typ}
  \end{equation}
  we must show
  $\forall \rho \in \TenvInp{\tenv}, \gamma \in \VenvInp{\venv}{\rho} . \ExpInp{\Tall{\Tvar}{\typ}}{\rho}(\gamma_1(\Tlam{\expr}), \gamma_2(\Tlam{\expr'}))$. So assume some $\rho \in \TenvInp{\tenv}$ and $\gamma \in \VenvInp{\venv}{\rho}$, by the definition of expression interpretation, our goal is now to show
  \begin{equation}
    \exists \val_1, \val_2 . \Tlam{\gamma_1(\expr)} \stepS \val_1 \land \Tlam{\gamma_2(\expr')} \stepS \val_2 \land \ValInp{\Tall{\Tvar}{\typ}}{\rho}(\val_1, \val_2)
  \end{equation}
  Note here that we have pushed the variable substitution inside the $\Lambda$-abstraction.
  Here we can simply use $\Tlam{\gamma_1(\expr)}$ for $\val_1$ and $\Tlam{\gamma_2(\expr')}$ for $\val_2$, as they are already values. Thus, we must show $\ValInp{\Tall{\Tvar}{\typ}}{\rho}(\Tlam{\gamma_1(\expr)}, \Tlam{\gamma_2(\expr')})$, which by definition means we have to show $\forall \typ_1, \typ_2, R \in Rel[\typ_1, \typ_2] . \ExpInp{\typ}{\rho'}(\gamma_1(\expr), \gamma_2(\expr'))$, where $\rho' = \rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]$. So assume some types $\typ_1, \typ_2$, and a relation $R \in Rel[\typ_1, \typ_2]$, then our goal is
  \begin{equation}\label{cmpt-tlam:goal}
    \ExpInp{\typ}{\rho'}(\gamma_1(\expr), \gamma_2(\expr'))
  \end{equation}
  We now instantiate (\ref*{cmpt-tlam:1}) with $\rho'$ and $\gamma$. Note that $\gamma \in \VenvInp{\venv}{\rho'}$ by corollary \ref{cor:VenvInp}. Thus, we get $\ExpInp{\typ}{\rho'}(\gamma_1(\expr), \gamma_2(\expr'))$, which is exactly what we had to show.
\end{proof}


\begin{lemma}[Cmpt-Tapp]
  $\inferrule
  { \LogRel{\tenv}{\venv}{\expr}{\expr'}{\Tall{\Tvar}{\typ}} }
  { \LogRel{\tenv}{\venv}{\Tapp{\expr}}{\Tapp{\expr'}}{\subst{\typ}{\Tvar}{\typ'}} }$
\end{lemma}
\begin{proof}
  Similar to proof given in \cite{DBLP:journals/corr/abs-1907-11133}.
  \todo{If space, do proof.}
\end{proof}

\section{Properties of LR}

\begin{lemma}[Adequacy of LR]\label{lem:LR_adeq}
  $\LogRel{\emptenv}{\empvenv}{\expr}{\expr'}{\Tbool} \implies \expr \Downarrow \val \iff \expr' \Downarrow \val$
\end{lemma}
\begin{proof}
  Assuming $\LogRel{\emptenv}{\empvenv}{\expr}{\expr'}{\Tbool}$, we must show 
  $\expr \Downarrow \val \iff \expr' \Downarrow \val$. By the definition of LR, we have that $\forall \rho \in \TenvInp{\emptenv}, \gamma \in \VenvInp{\empvenv}{\rho} . \ExpInp{\Tbool}{\rho}(\gamma_1(\expr), \gamma_2(\expr'))$. Given our definitions of $\mathcal{D}$ and $\mathcal{G}$, we can only instantiate it with the empty relational type substitution and the empty variable substitution. Doing this, we get $\ExpInp{\Tbool}{\emptyset}(\emptyset(\expr), \emptyset(\expr')) \equiv \ExpInp{\Tbool}{\emptyset}(\expr, \expr')$, which by definition means we have $\exists \val, \val' . \expr \stepS \val \land \expr' \stepS \val' \land \ValInp{\Tbool}{\emptyset}(\val, \val')$. Instantiating these values, we may conclude that $\expr \Downarrow \val$, $\expr' \Downarrow \val'$, and since $\ValInp{\Tbool}{\emptyset}(\val, \val')$, then either $\val = \val' = \True$, or $\val = \val' = \False$. In any case, $\val = \val'$, so that we can conclude $\expr \Downarrow \val \land \expr' \Downarrow \val$. From this we get what was wanted.
\end{proof}

\begin{lemma}[Congruency of LR]\label{lem:LR_cong}
  $LR$ is a congruence relation
\end{lemma}
\begin{proof}
  Follows immediately from the compatibility lemmas.
\end{proof}

\begin{theorem}\label{thm:LR_sound}
  $\LogRel{\tenv}{\venv}{\expr}{\expr'}{\typ} \implies \ctxRel{\tenv}{\venv}{\expr}{\expr'}{\typ}$
\end{theorem}
\begin{proof}
  We now know that LR is an adequate relation (lemma \ref{lem:LR_adeq}) and a congruence relation (lemma \ref{lem:LR_cong}). Further, it follows directly from the definition of LR, that all expressions in the relation are well-typed. Thus, by theorem \ref{thm:CE_eq_part2}, we may conclude $\LogRel{\tenv}{\venv}{\expr}{\expr'}{\typ} \implies \ctxRel{\tenv}{\venv}{\expr}{\expr'}{\typ}$.
\end{proof}

\begin{theorem}[Fundamental Theorem]\label{thm:fund}
  $\jdg{\tenv}{\venv}{\expr}{\typ} \implies \LogRel{\tenv}{\venv}{\expr}{\expr}{\typ}$
\end{theorem}
\begin{proof}
  Since LR is a congruence relation (lemma \ref{lem:LR_cong}), it follows directly from lemma \ref{lem:R_Cng_is_reflexive}.
\end{proof}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Examples of Application of Contextual Equivalence}
\label{ch:ACE}

\todo{draft}

\section{Identity}

\subsection{Identity reduction}
\begin{theorem}\label{thm:identity_reduction}
  $\jdg{\emptenv}{\empvenv}{\expr}{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}} \land
  \jdg{\emptenv}{\empvenv}{\val}{\typ} \implies 
  (\Tapp{\expr}) \; \val \stepS \val$
\end{theorem}
\begin{proof}
  So assume
  \begin{align}
    &\jdg{\emptenv}{\empvenv}{\expr}{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}}\label{ident:1}\\
    &\jdg{\emptenv}{\empvenv}{\val}{\typ}
  \end{align}
  Then we must show $(\Tapp{\expr}) \; \val \stepS \val$. From \ref*{ident:1} and by the fundamental theorem (theorem \ref{thm:fund}) we know $\LogRel{\emptenv}{\empvenv}{\expr}{\expr}{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}}$ from which we get $\forall \rho \in \TenvInp{\emptenv}, \gamma \in \VenvInp{\empvenv}{\rho} . \ExpInp{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}}{\rho}(\gamma_1(\expr), \gamma_2(\expr))$. By the definition of the type interpretation and value environment interpretation, we only have one choice of instantiation, so we instantiate both with the empty relational substitution, $\emptyset$. Thus we get $\ExpInp{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}}{\emptyset}(\expr, \expr)$. And from this, we may conclude $\exists \val_1, \val_2 . \expr \stepS \val_1 \land \expr \stepS \val_2 \land \ValInp{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}}{\emptyset}(\val_1, \val_2)$. By determinacy (theorem \ref{thm:determinacy}) these values must be the same, and from the value interpretation we further know that the value must be a type abstraction. Thus $\expr \stepS \Tlam \expr'$ and $\forall \typ_1, \typ_2, R \in Rel[\typ_1, \typ_2] . \ExpInp{\Tfunc{\Tvar}{\Tvar}}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]}(\expr', \expr')$. Here we use $\typ$ for $\typ_1$ and $\typ_2$, and the relation $R' = \{(\val, \val)\}$ for $R$, giving us $\ExpInp{\Tfunc{\Tvar}{\Tvar}}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R')}]}(\expr', \expr')$, meaning $\exists \val_1', \val_2' . \expr' \stepS \val_1' \land \expr' \stepS \val_2' \land \ValInp{\Tfunc{\Tvar}{\Tvar}}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R')}]}(\val_1', \val_2')$. Thus $\expr' \stepS \fun \var . \expr''$ and $\forall \valB_1, \valB_2 . \ValInp{\Tvar}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R')}]}(\valB_{1}, \valB_{2}) \implies \ExpInp{\Tvar}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R')}]}(\subst{\expr''}{\var}{\valB_1}, \subst{\expr''}{\var}{\valB_2})$. Using $\val$ for both $\valB_1$ and $\valB_2$, we get $\ExpInp{\Tvar}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R')}]}(\subst{\expr''}{\var}{\val}, \subst{\expr''}{\var}{\val})$ which means 
  $\exists \val_{1f}, \val_{2f} . \subst{\expr''}{\var}{\val} \stepS \val_{1f} \land \subst{\expr''}{\var}{\val} \stepS \val_{2f} \land \ValInp{\Tvar}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R')}]}(\val_{1f}, \val_{2f})$, which again means $\subst{\expr''}{\var}{\val} \stepS \val_f$ and $(\val_f, \val_f) \in R'$, but since $R'$ is a singleton, then we must have $\val_f = \val$. From the above, we have the following derivation
  \begin{equation}
    (\Tapp{\expr}) \; \val \stepS (\Tapp{\Tlam \expr'}) \; \val \step \expr' \; \val \stepS (\fun \var . \expr'') \; \val \step \subst{\expr''}{\var}{\val} \stepS \val_f = \val
  \end{equation}
  The first "$\stepS$" follows from $\expr \stepS \Tlam \expr'$. The following step holds by E-tapp-tlam. The next "$\stepS$" follows by $\expr' \stepS \fun \var . \expr''$. The next step holds by E-lam-app. and the final "$\stepS$" follows by $\subst{\expr''}{\var}{\val} \stepS \val_f$. Thus we have know shown $(\Tapp{\expr}) \; \val \stepS \val$.
\end{proof}

\subsection{Identity Contextual Equivalence}
\begin{theorem}
  $\jdg{\tenv}{\venv}{\expr}{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}} \implies \ctxRel{\tenv}{\venv}{\expr}{\Tlam \fun \var . \var}{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}}$
\end{theorem}
\begin{proof}
  The majority of this proof is simply unfolding definitions; one side of the coin will be working on the goal, and the other side will be working on the fundamental theorem. So we shall go fairly quickly through this.\\
  So assuming $\jdg{\tenv}{\venv}{\expr}{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}}$, we must show $\ctxRel{\tenv}{\venv}{\expr}{\Tlam \fun \var . \var}{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}}$. We shall do this by showing that the two expressions are logically related. Then contextual equivalence follows from theorem \ref{thm:LR_sound}. So we assume some $ \rho \in \TenvInp{\tenv}$ and $\gamma \in \VenvInp{\venv}{\rho}$. Then we must show $\exists \val_1, \val_2 . \gamma_1(\expr) \stepS \val_1 \land \Tlam \fun \var . \var \stepS \val_2 \land \ValInp{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}}{\rho}(\val_1, \val_2)$. By the fundamental theorem on our initial assumption and by instantiating this with $\rho$ and $\gamma$, we may conclude $\jdg{\emptenv}{\empvenv}{\gamma_2(\expr)}{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}}$ and $\gamma_1(\expr) \stepS \Tlam \expr_1$ and $\gamma_2(\expr) \stepS \Tlam \expr_2$ and 
  \begin{equation}\label{ident2:1}
    \forall \typ_1, \typ_2, R \in Rel[\typ_1, \typ_2] . \ExpInp{\Tfunc{\Tvar}{\Tvar}}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]}(\expr_1, \expr_2)
  \end{equation}
  Now use $\Tlam \expr_1$ for $\val_1$ and $\Tlam \fun \var . \var$ for $\val_2$ in our goal. Then we must show $\ValInp{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}}{\rho}(\Tlam \expr_1, \Tlam \fun \var . \var)$. So assume some $\typ_1$, $\typ_2$, and $R \in Rel[\typ_1, \typ_2]$, then we must show 
  $\exists \val_1', \val_2' . \expr_1 \stepS \val_1' \land \fun \var . \var \stepS \val_2' \land \ValInp{\Tfunc{\Tvar}{\Tvar}}{\rho'}(\val_1', \val_2')$, where $\rho' = \rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]$.
  Now instantiate (\ref*{ident2:1}) with $\typ_1$, $\typ_2$, $R$. Then we know $\expr_1 \stepS \fun \var . \expr_1'$, and $\expr_2 \stepS \fun \var . \expr_2'$, and
  \begin{equation}\label{ident2:2}
    \forall \valB_1, \valB_2 . \ValInp{\Tvar}{\rho'}(\valB_{1}, \valB_{2}) \implies \ExpInp{\Tvar}{\rho'}(\subst{\expr_1'}{\var}{\valB_1}, \subst{\expr_2'}{\var}{\valB_2})
  \end{equation}
  We then use $\fun \var . \expr_1'$ for $\val_1'$ and $\fun \var . \var$ for $\val_2'$ in our goal. Then we have to show $\ValInp{\Tfunc{\Tvar}{\Tvar}}{\rho'}(\fun \var . \expr_1', \fun \var . \var)$. So assume some $\valB_1$ and $\valB_2$, such that $\ValInp{\Tvar}{\rho'}(\valB_1, \valB_2)$, then it suffices to show $\exists \val_{1f}, \val_{2f} . \subst{\expr_1'}{\var}{\valB_1} \stepS \val_{1f} \land \valB_2 \stepS \val_{2f} \land \ValInp{\Tvar}{\rho'}(\val_{1f}, \val_{2f})$. Finally, instantiate (\ref*{ident2:2}) with $\valB_1$ and $\valB_2$. Then we know $\subst{\expr_1'}{\var}{\valB_1} \stepS \val_{1f}'$, and $\subst{\expr_2'}{\var}{\valB_2}) \stepS \val_{2f}'$, and $\ValInp{\Tvar}{\rho'}(\val_{1f}', \val_{2f}')$.
  Thus, by the definition of our value interpretation, $(\val_{1f}', \val_{2f}') \in R$. Now use $\val_{1f}'$ for $\val_{1f}$ and $\valB_2$ for $\val_{2f}$ in our goal. Then we must show $(\val_{1f'}, \valB_2) \in R$. To show this, we need to do some arguing about the reduction $(\Tapp{\gamma_2(\expr)}) \; \valB_2$. We have 
  \begin{equation*}
    (\Tapp{\gamma_2(\expr)}) \; \valB_2 \stepS (\Tapp{\Tlam \expr_2}) \; \valB_2 \step \expr_2 \; \valB_2 \stepS (\fun \var . \expr_2') \; \valB_2 \step \subst{\expr_2'}{\var}{\valB_2} \stepS \val_{2f}'
  \end{equation*}
  Since $\jdg{\emptenv}{\empvenv}{\gamma_2(\expr)}{\Tall{\Tvar}{\Tfunc{\Tvar}{\Tvar}}}$ then by theorem \ref{thm:identity_reduction} we may conclude $(\Tapp{\gamma_2(\expr)}) \; \valB_2 \stepS \valB_2$. Thus by determinacy of System F (theorem \ref{thm:determinacy}), we have that $\val_{2f}' = \valB_2$. Since we know $(\val_{1f}', \val_{2f}') \in R$, then it follows that $(\val_{1f}', \valB_2) \in R$, which was what we had to show.
\end{proof}


\section{Empty type}

\todo{explain briefly what the empty type is}

\begin{theorem}
  $\not\exists \expr . \jdg{\emptenv}{\empvenv}{\expr}{\Tall{\Tvar}{\Tvar}}$
\end{theorem}
\begin{proof}
  Assume for the sake of contradiction that $\exists \expr . \jdg{\emptenv}{\empvenv}{\expr}{\Tall{\Tvar}{\Tvar}}$. Then, by the fundamental theorem (theorem \ref{thm:fund}), we know that $\LogRel{\emptenv}{\empvenv}{\expr}{\expr}{\Tall{\Tvar}{\Tvar}}$, which means that $\forall \rho \in \TenvInp{\emptenv}, \gamma \in \VenvInp{\empvenv}{\rho} . 
  \ExpInp{\Tall{\Tvar}{\Tvar}}{\rho}(\gamma_1(\expr), \gamma_2(\expr))$. Here, pick the empty relational substitutions, so that $\ExpInp{\Tall{\Tvar}{\Tvar}}{\emptyset}(\expr, \expr)$. Which by definition means $\exists \val_1, \val_2 . \expr \stepS \val_1 \land \expr \stepS \val_2 \land \ValInpGen{\Tall{\Tvar}{\Tvar}}{\emptyset}$. From this we may conclude that $\expr \stepS \Tlam \expr'$, and $\forall \typ_1, \typ_2, R \in Rel[\typ_1, \typ_2] . \ExpInp{\Tvar}{[\map{\Tvar}{(\typ_1, \typ_2, R)}]}(\expr', \expr')$. Instantiate this with any two types (for example $\Tint$), and the empty relation, $R = \emptyset$. Then we have $\ExpInp{\Tvar}{[\map{\Tvar}{(\Tint, \Tint, \emptyset)}]}(\expr', \expr')$, from which we know $\exists \val_1, \val_2 . \expr' \stepS \val_1 \land \expr' \stepS \val_2 \land \ValInpGen{\Tvar}{[\map{\Tvar}{(\Tint, \Tint, \emptyset)}]}$. By the definition of the value interpretation for type variables, the last part gives us $(\val_1, \val_2) \in \emptyset$, which is a contradiction.
\end{proof}

\section{Idempotency}

Syntactic sugar:
$\Let \var = \expr in \expr' \triangleq (\fun \var . \expr') \; \expr$.

\begin{theorem}
  If $\jdg{\tenv}{\venv}{\expr}{\typ}$ then $\ctxRel{\tenv}{\venv}{\Let \var = \expr in (\var, \var)}{(\expr, \expr)}{\Tprod{\typ}{\typ}}$
\end{theorem}
\begin{proof}
  We will show the theorem by showing that the two expressions are logically related. Then, by theorem \ref{thm:LR_sound}, it follows that they are also contextually equivalent. So assume $\jdg{\tenv}{\venv}{\expr}{\typ}$, then we will show $\LogRel{\tenv}{\venv}{\Let \var = \expr in (\var, \var)}{(\expr, \expr)}{\Tprod{\typ}{\typ}}$. By definition of LR, we must show two things. First that both expressions are well-typed under $\tenv$ and $\venv$. This follows fairly easily from the assumption and by applying the typing rules, so we will not explain it here. Second that, when the expressions and types are closed, they are in the expression interpretation. So assume some $\rho \in \TenvInp{\tenv}$ and $\gamma \in \VenvInp{\venv}{\rho}$. Then we must show $\ExpInp{\Tprod{\typ}{\typ}}{\rho}(\gamma_1(\Let \var = \expr in (\var, \var)), \gamma_2((\expr, \expr)))$, which by the definition of the expression interpretation means we have to show
  \begin{align}
    &\jdg{\emptenv}{\empvenv}{\Let \var = \gamma_1(\expr) in (\var, \var)}{\rho_1(\typ)}\label{idem:goal_1.1}\\
    &\jdg{\emptenv}{\empvenv}{(\gamma_2(\expr), \gamma_2(\expr))}{\rho_2(\typ)}\label{idem:goal_1.2}\\
    &\exists \val_1, \val_2 . \Let \var = \gamma_1(\expr) in (\var, \var) \stepS \val_1 \land (\gamma_2(\expr), \gamma_2(\expr)) \stepS \val_2 \land\ValInpGen{\Tprod{\typ}{\typ}}{\rho}\label{idem:goal_1.3}
  \end{align}
  From the initial assumption and the fundamental theorem (theorem \ref{thm:fund}) we have that $\LogRel{\tenv}{\venv}{\expr}{\expr}{\typ}$, which, when we instantiate with $\rho$ and $\gamma$, gives us 
  \begin{align}
    &\jdg{\emptenv}{\empvenv}{\gamma_1(\expr)}{\rho_1(\typ)}\label{idem:1.1}\\
    &\jdg{\emptenv}{\empvenv}{\gamma_2(\expr)}{\rho_2(\typ)}\label{idem:1.2}\\
    &\exists \val_1', \val_2' . \gamma_1(\expr) \stepS \val_1' \land \gamma_2(\expr) \stepS \val_2' \land\ValInp{\typ}{\rho}(\val_1', \val_2')\label{idem:1.3}
  \end{align}
  From (\ref*{idem:1.1}) and (\ref*{idem:1.2}), we may prove the first two parts of the goal (\ref*{idem:goal_1.1}) and (\ref*{idem:goal_1.2}). So let's turn our attention the last part (\ref*{idem:goal_1.3}).
  \begin{multline}
    \Let \var = \gamma_1(\expr) in (\var, \var) \equiv (\fun \var . (\var, \var)) \; \gamma_1(\expr) \stepS (\fun \var . (\var, \var)) \; \val_1' \step\\ \subst{(\var, \var)}{\var}{\val_1'} \equiv (\val_1', \val_1')
  \end{multline}
  The first equivalence simply de-sugars the let expression. The next "$\stepS$" follows from (\ref{idem:1.3}). The next step is simply a lambda reduction, and the final equivalence is just performing the substitution.

  \begin{equation}
    (\gamma_2(\expr), \gamma_2(\expr)) \stepS (\val_2', \gamma_2(\expr)) \stepS (\val_2', \val_2')
  \end{equation}
  Both "$\stepS$" follows from (\ref{idem:1.3}).
  We here use $(\val_1', \val_1')$ for $\val_1$ and $(\val_2', \val_2')$ for $\val_2$. Then we must show
  \begin{equation}
    \ValInp{\Tprod{\typ}{\typ}}{\rho}((\val_1', \val_1'), (\val_2', \val_2'))\label{idem:goal_final}
  \end{equation}
  By the definition of the value interpretation for product type, it suffices to show well-typedness and $\ValInp{\typ}{\rho}(\val_1', \val_2') \land \ValInp{\typ}{\rho}(\val_1', \val_2')$. Both of which follows from the last part of (\ref{idem:1.3})
  \todo{prettify proof}
\end{proof}


\section{Commutativity}

\begin{theorem}
  If $\jdg{\tenv}{\venv}{\expr_1}{\typ_1}$ and $\jdg{\tenv}{\venv}{\expr_2}{\typ_2}$ then\\
  $\ctxRel{\tenv}{\venv}{\Let \var = \expr_2 in (\expr_1, \var)}{(\expr_1, \expr_2)}{\Tprod{\typ_1}{\typ_2}}$
\end{theorem}
\begin{proof}
  As in the previous proofs, we shall show this by showing the they are logically related. So assume $\jdg{\tenv}{\venv}{\expr_1}{\typ_1}$ and $\jdg{\tenv}{\venv}{\expr_2}{\typ_2}$. We will ignore showing well-typedness here, so assume some $\rho \in \TenvInp{\tenv}$ and $\gamma \in \VenvInp{\venv}{\rho}$, then we must show $\ExpInp{\Tprod{\typ_1}{\typ_2}}{\rho}(\gamma_1(\Let \var = \expr_2 in (\expr_1, \var)), \gamma_2((\expr_1, \expr_2)))$, which by the definition of the expression interpretation means we have to show
  \begin{multline}\label{commutativity:goal_1}
    \exists \val_1, \val_2 . \Let \var = \gamma_1(\expr_2) in (\gamma_1(\expr_1), \var) \stepS \val_1 \land (\gamma_2(\expr_1), \gamma_2(\expr_2)) \stepS \val_2 \land\\ \ValInpGen{\Tprod{\typ_1}{\typ_2}}{\rho}
  \end{multline}
  From the initial assumptions and the fundamental theorem (theorem \ref{thm:fund}) we have that $\LogRel{\tenv}{\venv}{\expr_1}{\expr_1}{\typ_1}$ and $\LogRel{\tenv}{\venv}{\expr_2}{\expr_2}{\typ_2}$, which, when we instantiate with $\rho$ and $\gamma$, gives us
  \begin{align}
    &\exists \val_{1f_1}, \val_{1f_2} . \gamma_1(\expr_1) \stepS \val_{1f_1} \land \gamma_2(\expr_1) \stepS \val_{1f_2} \land \ValInp{\typ_1}{\rho}(\val_{1f_1}, \val_{1f_2})\label{commutativity:1.1}\\
    &\exists \val_{2f_1}, \val_{2f_2} . \gamma_1(\expr_2) \stepS \val_{2f_1} \land \gamma_2(\expr_2) \stepS \val_{2f_2} \land \ValInp{\typ_2}{\rho}(\val_{2f_1}, \val_{2f_2})\label{commutativity:1.2}
  \end{align}
  Now we will instantiate our goal (\ref*{commutativity:goal_1}). Use $(\val_{1f_1}, \val_{2f_1})$ for $\val_1$ and $(\val_{1f_2}, \val_{2f_2})$ for $\val_2$. Thus, we must show 
  \begin{align}
    &\Let \var = \gamma_1(\expr_2) in (\gamma_1(\expr_1), \var) \stepS (\val_{1f_1}, \val_{2f_1})\label{commutativity:goal_2.1}\\
    &(\gamma_2(\expr_1), \gamma_2(\expr_2)) \stepS (\val_{1f_2}, \val_{2f_2})\label{commutativity:goal_2.2}\\
    &\ValInp{\Tprod{\typ_1}{\typ_2}}{\rho}((\val_{1f_1}, \val_{2f_1}), (\val_{1f_2}, \val_{2f_2}))\label{commutativity:goal_2.3}
  \end{align}
  The derivations are fairly straightforward to show. For the first one (\ref*{commutativity:goal_2.1}) we have
  \begin{multline*}
    \Let \var = \gamma_1(\expr_2) in (\gamma_1(\expr_1), \var) \equiv (\fun \var . (\gamma_1(\expr_1), \var)) \; \gamma_1(\expr_2) \stepS\\ (\fun \var . (\gamma_1(\expr_1), \var)) \; \val_{2f_1} \step \subst{(\gamma_1(\expr_1), \var)}{\var}{\val_{2f_1}} \equiv (\gamma_1(\expr_1), \val_{2f_1}) \stepS (\val_{1f_1}, \val_{2f_1})
  \end{multline*}
  For the second one (\ref*{commutativity:goal_2.2}) we have
  \begin{equation*}
    (\gamma_2(\expr_1), \gamma_2(\expr_2)) \stepS (\val_{1f_2}, \gamma_2(\expr_2)) \stepS (\val_{1f_2}, \val_{2f_2})
  \end{equation*}
  Finally, (\ref*{commutativity:goal_2.3}) follows from the last parts of (\ref*{commutativity:1.1}) and (\ref*{commutativity:1.2}).
  \todo{prettify proof}
\end{proof}


\section{Lam hoisting}

\begin{theorem}
  If $\jdg{\tenv}{\venv}{\expr_1}{\typ}$ and $\jdg{\tenv}{\venv, \varB : \typ, \var : \typ_1}{\expr_2}{\typ_2}$ then\\
  $\ctxRel{\tenv}{\venv}{\Let \varB = \expr_1 in \fun \var . \expr_2}{\fun \var . \Let \varB = \expr_1 in \expr_2}{\Tfunc{\typ_1}{\typ_2}}$
\end{theorem}
\begin{proof}
  So assuming 
  \begin{align}
    &\jdg{\tenv}{\venv}{\expr_1}{\typ}\label{lamhoist:1}\\
    &\jdg{\tenv}{\venv, \varB : \typ, \var : \typ_1}{\expr_2}{\typ_2}\label{lamhoist:2}
  \end{align}
  it suffices to show $\LogRel{\tenv}{\venv}{\Let \varB = \expr_1 in \fun \var . \expr_2}{\fun \var . \Let \varB = \expr_1 in \expr_2}{\Tfunc{\typ_1}{\typ_2}}$. Using our two assumptions (\ref*{lamhoist:1} and \ref*{lamhoist:2}), along with the typing rules T-lam and T-app, we may conclude
  \begin{align}
    &\jdg{\tenv}{\venv}{\Let \varB = \expr_1 in \fun \var . \expr_2}{\Tfunc{\typ_1}{\typ_2}}\label{lamhoist:exp1_wt}\\
    &\jdg{\tenv}{\venv}{\fun \var . \Let \varB = \expr_1 in \expr_2}{\Tfunc{\typ_1}{\typ_2}}\label{lamhoist:exp2_wt}
  \end{align}
  So assume some $\rho \in \TenvInp{\tenv}$ and $\gamma \in \VenvInp{\venv}{\rho}$, then we must show $\ExpInp{\Tfunc{\typ_1}{\typ_2}}{\rho}(\Let \varB = \gamma_1(\expr_1) in \fun \var . \gamma_1(\expr_2), \fun \var . \Let \varB = \gamma_2(\expr_1) in \gamma_2(\expr_2))$
  The closedness and well-typedness follows from applying the fundamental theorem on the above judgements (\ref*{lamhoist:exp1_wt} and \ref*{lamhoist:exp2_wt}), and instantiating with $\rho$ and $\gamma$. So what remains to be shown is
  \begin{multline}\label{lamhoist:goal_1}
    \exists \val_1, \val_2 . (\Let \varB = \gamma_1(\expr_1) in \fun \var . \gamma_1(\expr_2)) \stepS \val_1 \land\\
    (\fun \var . \Let \varB = \gamma_2(\expr_1) in \gamma_2(\expr_2)) \stepS \val_2 \land
    \ValInp{\Tfunc{\typ_1}{\typ_2}}{\rho}(\val_1, \val_2)
  \end{multline}
  From the fundamental theorem on (\ref{lamhoist:1}) instantiated with $\rho$ and $\gamma$, we know that
  \begin{equation}\label{lamhoist:1.1}
    \gamma_1(\expr_1) \stepS \val_{y_1} \land \gamma_2(\expr_1) \stepS \val_{y_2} \land \ValInp{\typ}{\rho}(\val_{y_1}, \val_{y_2})
  \end{equation}
  for some values $\val_{y_1}, \val_{y_2}$. We also get that $\jdg{\emptenv}{\empvenv}{\gamma_2(\expr_1)}{\rho_1(\typ)}$.
  In our goal (\ref{lamhoist:goal_1}), we use $\fun \var . \subst{\gamma_1(\expr_2)}{\varB}{\val_{y_1}}$ for $\val_1$ and $\fun \var . \Let \varB = \gamma_2(\expr_1) in \gamma_2(\expr_2)$ for $\val_2$. One may see that the first derivation holds by desugaring the let expression into a function application, then using $\gamma_1(\expr_1) \stepS \val_{y_1}$ from (\ref{lamhoist:1.1}) and the E-lam-app rule to conclude
  \begin{multline*}
    (\Let \varB = \gamma_1(\expr_1) in \fun \var . \gamma_1(\expr_2)) \equiv (\fun \varB . (\fun \var . \gamma_1(\expr_2))) \; \gamma_1(\expr_1) \stepS\\ (\fun \varB . (\fun \var . \gamma_1(\expr_2))) \; \val_{y_1} \step \fun \var . \subst{\gamma_1(\expr_2)}{\varB}{\val_{y_1}}
  \end{multline*}
  The second derivation holds trivially, so all we need to show is 
  \begin{equation}
    \ValInp{\Tfunc{\typ_1}{\typ_2}}{\rho}(\fun \var . \subst{\gamma_1(\expr_2)}{\varB}{\val_{y_1}}, \fun \var . \Let \varB = \gamma_2(\expr_1) in \gamma_2(\expr_2))
  \end{equation}
  So we assume some $\valB_1, \valB_2$, and $\ValInp{\typ_1}{\rho}(\valB_1, \valB_2)$, and show 
  \begin{multline}\label{lamhoist:goal_2}
    \exists \val_1, \val_2 . \subst{(\subst{\gamma_1(\expr_2)}{\varB}{\val_{y_1}})}{\var}{\valB_1} \stepS \val_1 \land\\
    \subst{(\Let \varB = \gamma_2(\expr_1) in \gamma_2(\expr_2))}{\var}{\valB_2} \stepS \val_2 \land
    \ValInp{\typ_2}{\rho}(\val_1, \val_2)
  \end{multline}
  We now use the fundamental theorem on (\ref{lamhoist:2}) and instantiate it with $\rho$ and $\gamma' = \gamma[\map{\varB}{(\val_{y_1}, \val_{y_2})}][\map{\var}{(\valB_1, \valB_2)}]$. Note that this is fine as both variables map to pairs of values that are in the value interpretation at their respective types. From this we get
  \begin{equation}\label{lamhoist:2.1}
    \gamma'_1(\expr_2) \stepS \val_{f_1} \land \gamma'_2(\expr_2) \stepS \val_{f_2} \land \ValInp{\typ_2}{\rho}(\val_{f_1}, \val_{f_2})
  \end{equation}
  For some values $\val_{f_1}, \val_{f_2}$.
  Finally, in our goal (\ref{lamhoist:goal_2}), we use $\val_{f_1}$ for $\val_1$, and $\val_{f_2}$ for $\val_2$. Firstly, $\ValInp{\typ_2}{\rho}(\val_{f_1}, \val_{f_2})$ follows directly from (\ref{lamhoist:2.1}), so let's show that the derivations hold. The first one holds by
  \begin{align*}
    \subst{(\subst{\gamma_1(\expr_2)}{\varB}{\val_{y_1}})}{\var}{\valB_1}
    &\equiv
    \subst{\gamma_1[\map{\varB}{\val_{y_1}](\expr_2)}}{\var}{\valB_1} & \text{(substitution lemma)}\\
    &\equiv
    \gamma_1[\map{\varB}{\val_{y_1}}][\map{\var}{\valB_1}](\expr_2) & \text{(substitution lemma)}\\
    &\equiv \gamma'_1(\expr_2)\\
    &\stepS \val_{f_1} &\text{(from (\ref{lamhoist:2.1}))}
  \end{align*}
  The second derivation holds by
  \begin{align*}
    \subst{(\Let \varB = \gamma_2(\expr_1) in \gamma_2(\expr_2))}{\var}{\valB_2}
    &\equiv
    \Let \varB = \subst{\gamma_2(\expr_1)}{\var}{\valB_2} in \subst{\gamma_2(\expr_2)}{\var}{\valB_2}\\
    &\equiv
    \Let \varB = \gamma_2(\expr_1) in \subst{\gamma_2(\expr_2)}{\var}{\valB_2}\\
    &\stepS
    \Let \varB = \val_{y_2} in \subst{\gamma_2(\expr_2)}{\var}{\valB_2}\\
    &\step
    \subst{(\subst{\gamma_2(\expr_2)}{\var}{\valB_2})}{\varB}{\val_{y_2}}\\
    &\equiv
    \subst{\gamma_2[\map{\var}{\valB_2}](\expr_2)}{\varB}{\val_{y_2}}\\
    &\equiv
    \gamma_2[\map{\var}{\valB_2}][\map{\varB}{\val_{y_2}}](\expr_2)\\
    &\equiv
    \gamma'_2(\expr_2)\\
    &\stepS \val_{f_2}
  \end{align*}
  In the first equivalence, we simply push in the substitution. The next equivalence holds as $\gamma_2(\expr_1)$ is a closed expression. Next we use the fact that $\gamma_2(\expr_1) \stepS \val_{y_2}$. Following that, the let-expression desugars into a function application where both expressions are values, so we use E-lam-app to take a step. Then we apply the substitution lemma twice, and the last step holds by (\ref{lamhoist:2.1}).
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Comparison to Other Work and Ideas for Future Work}
\label{ch:COWFW}

\todo{draft}

% Idea for future work:
% * add recursive functions (fixpoint) to the language.
%   this will make it non-terminating.
%   project started out with this, but defining LR became much harder
%   requires step-indexed LR
% * Iris maybe?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}
\label{ch:conclusion}

\todo{conclude on the problem statement from the introduction}

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

\todo{\dots}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain} 
\bibliography{refs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{The Technical Details}

\todo{\dots}

\section{Congruence Rules for Alternative Definition of Contextual Equivalence}\label{appendix:Cng}

\begin{mathpar}
  \inferrule*[lab=Cng-var]
    {(\var : \typ) \in \venv}
    {\jdgRel{\tenv}{\venv}{\var}{}{\var}{\typ} }
  \and
  \inferrule*[lab=Cng-unit]{ }{ \jdgRel{\tenv}{\venv}{\TT}{}{\TT}{\Tunit} }
  \and
  \inferrule*[lab=Cng-int]{ }{ \jdgRel{\tenv}{\venv}{\Num{n}}{}{\Num{n}}{\Tint} }
  \and
  \inferrule*[lab=Cng-add]
    { {\jdgRel{\tenv}{\venv}{\expr_1}{}{\expr_1'}{\Tint} } \and
    { \jdgRel{\tenv}{\venv}{\expr_2}{}{\expr_2'}{\Tint} } }
    { \jdgRel{\tenv}{\venv}{\expr_1 + \expr_2}{}{\expr_1' + \expr_2'}{\Tint} }
  \and
  \inferrule*[lab=Cng-sub]
    { {\jdgRel{\tenv}{\venv}{\expr_1}{}{\expr_1'}{\Tint} } \and
    { \jdgRel{\tenv}{\venv}{\expr_2}{}{\expr_2'}{\Tint} } }
    { \jdgRel{\tenv}{\venv}{\expr_1 - \expr_2}{}{\expr_1' - \expr_2'}{\Tint} }
  \and
  \inferrule*[lab=Cng-le]
    { {\jdgRel{\tenv}{\venv}{\expr_1}{}{\expr_1'}{\Tint} } \and
    { \jdgRel{\tenv}{\venv}{\expr_2}{}{\expr_2'}{\Tint} } }
    { \jdgRel{\tenv}{\venv}{\expr_1 \le \expr_2}{}{\expr_1' \le \expr_2'}{\Tbool} }
  \and
  \inferrule*[lab=Cng-lt]
    { {\jdgRel{\tenv}{\venv}{\expr_1}{}{\expr_1'}{\Tint} } \and
    { \jdgRel{\tenv}{\venv}{\expr_2}{}{\expr_2'}{\Tint} } }
    { \jdgRel{\tenv}{\venv}{\expr_1 < \expr_2}{}{\expr_1' < \expr_2'}{\Tbool} }
  \and
  \inferrule*[lab=Cng-eq]
    { {\jdgRel{\tenv}{\venv}{\expr_1}{}{\expr_1'}{\Tint} } \and
    { \jdgRel{\tenv}{\venv}{\expr_2}{}{\expr_2'}{\Tint} } }
    { \jdgRel{\tenv}{\venv}{\expr_1 = \expr_2}{}{\expr_1' = \expr_2'}{\Tbool} }
  \and
  \inferrule*[lab=Cng-true]{ }{ \jdgRel{\tenv}{\venv}{\True}{}{\True}{\Tbool} }
  \and
  \inferrule*[lab=Cng-false]{ }{ \jdgRel{\tenv}{\venv}{\False}{}{\False}{\Tbool} }
  \and
  \inferrule*[lab=Cng-if]
    { {\jdgRel{\tenv}{\venv}{\expr_1}{}{\expr_1'}{\Tbool} } \and
    { \jdgRel{\tenv}{\venv}{\expr_2}{}{\expr_2'}{\typ} } \and
    { \jdgRel{\tenv}{\venv}{\expr_3}{}{\expr_3'}{\typ} }
    }
    { \jdgRel{\tenv}{\venv}{\If \expr_1 then \expr_2 else \expr_3}{}{\If {\expr_1'} then {\expr_2'} else {\expr_3'}}{\typ} }
  \and
  \inferrule*[lab=Cng-pair]
    { {\jdgRel{\tenv}{\venv}{\expr_1}{}{\expr_1'}{\typ_1} } \and
    { \jdgRel{\tenv}{\venv}{\expr_2}{}{\expr_2'}{\typ_2} } }
    { \jdgRel{\tenv}{\venv}{(\expr_1,\expr_2)}{}{(\expr_1', \expr_2')}{\Tprod{\typ_1}{\typ_2}} }
  \and
  \inferrule*[lab=Cng-fst]
    { \jdgRel{\tenv}{\venv}{\expr}{}{\expr'}{\Tprod{\typ_1}{\typ_2}} }
    { \jdgRel{\tenv}{\venv}{\Fst \expr}{}{\Fst \expr'}{\typ_1} }
  \and
  \inferrule*[lab=Cng-snd]
    { \jdgRel{\tenv}{\venv}{\expr}{}{\expr'}{\Tprod{\typ_1}{\typ_2}} }
    { \jdgRel{\tenv}{\venv}{\Snd \expr}{}{\Snd \expr'}{\typ_2} }
  \and
  \inferrule*[lab=Cng-inj1]
    { \jdgRel{\tenv}{\venv}{\expr}{}{\expr'}{\typ_1} }
    { \jdgRel{\tenv}{\venv}{\Inj{1} \expr}{}{\Inj{1} \expr'}{\Tsum{\typ_1}{\typ_2}} }
  \and
  \inferrule*[lab=Cng-inj2]
    { \jdgRel{\tenv}{\venv}{\expr}{}{\expr'}{\typ_2} }
    { \jdgRel{\tenv}{\venv}{\Inj{2} \expr}{}{\Inj{2} \expr'}{\Tsum{\typ_1}{\typ_2}} }
\end{mathpar}
\begin{mathpar}
  \inferrule*[lab=Cng-match]
    { {\jdgRel{\tenv}{\venv}{\expr_1}{}{\expr_1'}{\Tsum{\typ_1}{\typ_2}} } \and
    { \jdgRel{\tenv}{\venv, \var : \typ_1}{\expr_2}{}{\expr_2'}{\typ} } \and
    { \jdgRel{\tenv}{\venv, \var : \typ_2}{\expr_3}{}{\expr_3'}{\typ} }
    }
    { \jdgRel{\tenv}{\venv}{\Match \expr_1 with \Inj{1} \var => \expr_2 | \Inj{2} \var => \expr_3 end}{}{\Match \expr_1' with \Inj{1} \var => \expr_2' | \Inj{2} \var => \expr_3' end}{\typ} }
  \and
  \inferrule*[lab=Cng-lam]
    { \jdgRel{\tenv}{\venv, x : \typ_1}{\expr}{}{\expr'}{\typ_2} }
    { \jdgRel{\tenv}{\venv}{\fun \var . \expr}{}{\fun \var . \expr'}{\Tfunc{\typ_1}{\typ_2}} }
  \and
  \inferrule*[lab=Cng-app]
    { {\jdgRel{\tenv}{\venv}{\expr_1}{}{\expr_1'}{\Tfunc{\typ_1}{\typ_2}} } \and
    { \jdgRel{\tenv}{\venv}{\expr_2}{}{\expr_2'}{\typ_1} } }
    { \jdgRel{\tenv}{\venv}{\expr_1 \; \expr_2}{}{\expr_1' \; \expr_2'}{\typ_2} }
  \and
  \inferrule*[lab=Cng-Tlam]
    { \jdgRel{\tenv, \Tvar}{\venv}{\expr}{}{\expr'}{\typ} }
    { \jdgRel{\tenv}{\venv}{\Tlam{\expr}}{}{\Tlam{\expr'}}{\Tall{\Tvar}{\typ}} }
  \and
  \inferrule*[lab=Cng-Tapp]
    { \jdgRel{\tenv}{\venv}{\expr}{}{\expr'}{\Tall{\Tvar}{\typ}} }
    { \jdgRel{\tenv}{\venv}{\Tapp{\expr}}{}{\Tapp{\expr'}}{\subst{\typ}{\Tvar}{\typ'}} }
\end{mathpar}

\section{Additional results}

\begin{lemma}\label{lem:ValInpTypSub}
  $\Tvar \notin \mathrm{dom}(\rho) \land \Tvar \notin \mathrm{free}(\tau) \implies \forall \typ_1, \typ_2, R \in Rel[\typ_1, \typ_2] . \ValInp{\typ}{\rho}(\val_1, \val_2) \iff \ValInp{\typ}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]}(\val_1, \val_2)$
\end{lemma}
\begin{proof}
  The proof won't be carried out here, but it follows by induction on $\typ$.
\end{proof}

\begin{corollary}\label{cor:VenvInp}
  $\Tvar \notin \mathrm{dom}(\rho) \land \Tvar \notin \mathrm{free}(\venv) \implies \forall \typ_1, \typ_2, R \in Rel[\typ_1, \typ_2] . \VenvInp{\venv}{\rho} = \VenvInp{\venv}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]}$
\end{corollary}
\begin{proof}
  Assuming $\Tvar \notin \mathrm{dom}(\rho)$, $\Tvar \notin \mathrm{free}(\venv)$, and some $\typ_1$, $\typ_2$, and $R \in Rel[\typ_1, \typ_2]$, we must show $\VenvInp{\venv}{\rho} = \VenvInp{\venv}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]}$. We proceed by induction on $\venv$. The base case is trivial: $\VenvInp{\empvenv}{\rho} = \VenvInp{\empvenv}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]} = \{\emptyset\}$. So let's show the inductive step. Our induction hypothesis is $\VenvInp{\venv}{\rho} = \VenvInp{\venv}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]}$, and we must show $\VenvInp{\venv, \var : \typ}{\rho} = \VenvInp{\venv, \var : \typ}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]}$, which is equivalent to showing $\gamma \in \VenvInp{\venv, \var : \typ}{\rho} \iff \gamma \in \VenvInp{\venv, \var : \typ}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]}$, for all $\gamma$. Both directions of the double implication are similar, so we show just the "$\implies$" direction. So assuming $\gamma \in \VenvInp{\venv, \var : \typ}{\rho}$, we must show $\gamma \in \VenvInp{\venv, \var : \typ}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]}$. From $\gamma \in \VenvInp{\venv, \var : \typ}{\rho}$ we may conclude that $\gamma = \gamma'[\map{\var}{(\val_1, \val_2)}]$, and that $\gamma' \in \VenvInp{\venv}{\rho}$ and $\ValInp{\typ}{\rho}(\val_1, \val_2)$. From this and lemma \ref{lem:ValInpTypSub} we know that $\ValInp{\typ}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]}(\val_1, \val_2)$, and from our induction hypothesis, we get $\gamma' \in \VenvInp{\venv}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]}$. So by the definition of $\mathcal{G}$, we may conclude $\gamma \in \VenvInp{\venv, \var : \typ}{\rho[\map{\Tvar}{(\typ_1, \typ_2, R)}]}$.
\end{proof}

\begin{lemma}[Substitution lemma LR]\label{lem:subst_LR}
  If $\jdg{\tenv}{\venv}{\expr}{\typ}$ and $\rho \in \TenvInp{\tenv}$ and $\gamma \in \VenvInp{\venv}{\rho}$, then $\jdg{\emptenv}{\empvenv}{\gamma_1(\expr)}{\rho_1(\typ)}$ and $\jdg{\emptenv}{\empvenv}{\gamma_2(\expr)}{\rho_2(\typ)}$
\end{lemma}
\begin{proof}
  This follows fairly easily from the fundamental theorem: by the fundamental theorem on $\jdg{\tenv}{\venv}{\expr}{\typ}$, we have $\forall \rho \in \TenvInp{\tenv}, \gamma \in \VenvInp{\venv}{\rho} . 
  \ExpInp{\typ}{\rho}(\gamma_1(\expr), \gamma_2(\expr))$. Using our $\rho$ and $\gamma$, we get $\ExpInp{\typ}{\rho}(\gamma_1(\expr), \gamma_2(\expr))$. By definition of the expression interpretation, this means that $\jdg{\emptenv}{\empvenv}{\gamma_1(\expr)}{\rho_1(\typ)}$ and $\jdg{\emptenv}{\empvenv}{\gamma_2(\expr)}{\rho_2(\typ)}$, which was what we wanted.
\end{proof}


\end{document}

