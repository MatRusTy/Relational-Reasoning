\documentclass[twoside,11pt,openright]{report}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
\usepackage{mathptmx}
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage[en-GB]{datetime2}
\DTMlangsetup[en-GB]{showdayofmonth=false}
\usepackage{lipsum}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}


% Theorems, Corollaries, and Lemmas
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BNF Grammar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\BNFdef}{::=}
\newcommand{\ALT}{~|~}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Syntax
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Keyword}[1]{{\color{blue} \mathsf{#1}}}

\newcommand{\var}{x}
\newcommand{\varB}{y}
\newcommand{\varC}{z}
\newcommand{\expr}{e}
\newcommand{\val}{v}
\newcommand{\valB}{w}
\newcommand{\TT}{()}
\newcommand{\Num}[1]{\overline{#1}}
\newcommand{\True}{\Keyword{true}}
\newcommand{\False}{\Keyword{false}}
\newcommand{\IfCmd}{\Keyword{if}}
\newcommand{\ThenCmd}{\Keyword{then}}
\newcommand{\ElseCmd}{\Keyword{else}}
\def\If#1then#2else#3{\IfCmd{}\;#1\;\ThenCmd{}\;#2\;\ElseCmd{}\;#3}
\newcommand{\Fst}{\Keyword{fst}\;}
\newcommand{\Snd}{\Keyword{snd}\;}
\newcommand{\Inj}[1]{\Keyword{inj}_{#1}\;}
\newcommand{\MatchCmd}{\Keyword{match}}
\newcommand{\WithCmd}{\Keyword{with}}
\newcommand{\EndCmd}{\Keyword{end}}
\def\Match#1with#2=>#3|#4=>#5end{\MatchCmd{}\;#1\;\WithCmd{}\;#2\Rightarrow#3 \;|\;#4\Rightarrow#5\;\EndCmd{}}
\def\MatchV[#1]#2with#3=>#4|#5=>#6end{\begin{aligned}[#1]&\MatchCmd{}\;#2\;\WithCmd{}\\ & \hspace{0.5em}#3\Rightarrow#4\\ & | \hspace{0.2em}#5\Rightarrow#6\\ &\EndCmd{}\end{aligned}}
\newcommand{\RecCmd}{\Keyword{rec}}
\long\def\Rec#1 #2:=#3{\RecCmd\; #1(#2) := #3}

\newcommand{\Tvar}{X}
\newcommand{\TvarB}{Y}
\newcommand{\TvarC}{Z}

\newcommand{\Tlam}{\Lambda\;}
\newcommand{\Tapp}[1]{#1\;\_}

\newcommand{\empelctx}{[]}
\newcommand{\elctx}{K}

\newcommand{\subst}[3]{#1{\left[#3 \middle/ #2 \right]}}

\newcommand{\empctx}{[\cdot]}
\newcommand{\ctx}{C}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Typing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Tunit}{\mathsf{Unit}}
\newcommand{\Temp}{\mathsf{Emp}}
\newcommand{\Tnat}{\mathbb{N}} % not needed
\newcommand{\Tint}{\mathbb{Z}}
\newcommand{\Tbool}{\mathbb{B}}
\newcommand{\Tprod}[2]{#1 \times #2}
\newcommand{\Tsum}[2]{#1 + #2}
\newcommand{\Tfunc}[2]{#1 \rightarrow #2}
\newcommand{\Tall}[2]{\forall #1.\; #2}

\newcommand{\typ}{\tau}
\newcommand{\tctx}{\Gamma}
\newcommand{\tenv}{\Xi}
\newcommand{\hctx}{\Sigma} % not needed
\newcommand{\emptctx}{\bullet}
\newcommand{\emptenv}{\bullet}

% Judgements
\def\envs#1#2\exp#3\type#4{#1 \; | \; #2 \; \vdash #3 : #4}
\def\envstyp#1#2\type#3{#1 \; | \; #2 \; \vdash #3}

\def\envscteq#1#2\exp1#3\exp2#4\type#5
  {#1 \; | \; #2 \; \vdash #3 \approx^{ctx} #4 : #5}

% Step
\newcommand{\step}{\rightarrow}
\newcommand{\stepS}{\rightarrow^*}

% Head-Step
\newcommand{\hstep}{\rightarrow_h}
\newcommand{\hstepRel}[2]{#1 \hstep #2}

% Other
\newcommand{\Val}[1]{\mathrm{Val}(#1)}

% TODO-command
\newcommand{\todo}[1]{{\color[rgb]{.5,0,0}\textbf{$\blacktriangleright$#1$\blacktriangleleft$}}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
{\Huge\sf Relational Reasoning\\[1ex](Relationel r√¶sonnement)}\\[4ex]
{\huge\sf Mathias Pedersen, 201808137}\\[2ex]
\noindent\rule{\linewidth}{1mm}\\[4ex]
\noindent{\Large\sf Bachelor Report (15 ECTS) in Computer Science\\[1ex]
Advisor: Amin Timany\\[1ex]
Department of Computer Science, Aarhus University\\[1ex]  
\today \\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage
\linespread{1.15}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

\todo{in English\dots}

\vspace{2ex}
\begin{flushright}
  \emph{Mathias Pedersen,}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\label{ch:intro}

\todo{motivate and explain the problem to be addressed}

\todo{example of a citation: \cite{DBLP:conf/sas/ChristensenMS03}}
\todo{get your bibtex entries from \url{https://dblp.org/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Definition of Language}
\label{ch:DoL}

\todo{create draft}\\
Syntax
\begin{align*}
  \expr \BNFdef & \TT \ALT & \text{(unit value)}\\
                & \var \ALT & \text{(variables)}\\
                & \Num{n} \ALT \expr + \expr \ALT \expr - \expr \ALT
                  \expr \le \expr \ALT \expr < \expr \ALT 
                  \expr = \expr \ALT & \text{(integers)}\\
                & \True \ALT \False \ALT {\If \expr then \expr else \expr} \ALT
                  & \text{(booleans)}\\
                & (\expr, \expr) \ALT \Fst \expr \ALT \Snd \expr \ALT
                  & \text{(products)}\\
                & \Inj{1} \expr \ALT \Inj{2} \expr \ALT 
                  \Match \expr with \Inj{1} \var => \expr | \Inj{2} \var => \expr end \ALT
                  & \text{(sums)}\\
                & \Rec f \var := \expr \ALT \expr \; \expr
                  & \text{(recursive functions)}\\
                & \Tlam \expr \ALT \Tapp{\expr} & \text{(polymorphism)}\\[8pt]
  \val \BNFdef  & \TT \ALT \Num{n} \ALT \True \ALT \False \ALT
                  (\val, \val) \ALT \Inj{1} \val \ALT \Inj{2} \val \ALT
                  \Rec f \var := \expr \ALT \Tlam \expr
                  & \text{(values)}\\[8pt]
  \typ \BNFdef  & \Tunit \ALT \Tint \ALT \Tbool \ALT {\Tprod \typ \typ} \ALT
                  {\Tsum \typ \typ} \ALT {\Tfunc \typ \typ} \ALT 
                  {\Tall \Tvar \typ} & \text{(types)}\\[8pt]
  \elctx \BNFdef& \empelctx \ALT 
                  \elctx + \expr \ALT \val + \elctx \ALT
                  \elctx - \expr \ALT \val - \elctx \ALT
                  \elctx \le \expr \ALT \val \le \elctx \ALT
                  \elctx < \expr \ALT \val < \elctx \ALT 
                  & \text{(evaluation context)}\\
                & \elctx = \expr \ALT \val = \elctx \ALT
                  {\If \elctx then \expr else \expr} \ALT
                  (\elctx, \expr) \ALT (\val, \elctx) \ALT
                  \Fst \elctx \ALT \Snd \elctx \ALT\\
                & \Inj{1} \elctx \ALT \Inj{2} \elctx \ALT
                  \Match \elctx with \Inj{1} \var => \expr | \Inj{2} \var => \expr end \ALT
                  \elctx \; \expr \ALT \val \; \elctx \ALT \Tapp{\elctx}
\end{align*}
\newpage
Typing rules
\begin{mathpar}
  \inferrule*[lab=T-var]
    {(\var : \typ) \in \tctx}
    {\envs \tenv \tctx \exp \var \type \typ}
  \and
  \inferrule*[lab=T-unit]{ }{\envs \tenv \tctx \exp \TT \type \Tunit}
  \and
  \inferrule*[lab=T-int]{ }{\envs \tenv \tctx \exp \Num{n} \type \Tint}
  \and
  \inferrule*[lab=T-add]
    {{\envs \tenv \tctx \exp \expr_1\type \Tint} \and {\envs \tenv \tctx \exp \expr_2\type \Tint}}
    {\envs \tenv \tctx \exp \expr_1 + \expr_2 \type \Tint}
  \and
  \inferrule*[lab=T-sub]
    {{\envs \tenv \tctx \exp \expr_1\type \Tint} \and {\envs \tenv \tctx \exp \expr_2\type \Tint}}
    {\envs \tenv \tctx \exp \expr_1 - \expr_2 \type \Tint}
  \and
  \inferrule*[lab=T-le]
    {{\envs \tenv \tctx \exp \expr_1\type \Tint} \and {\envs \tenv \tctx \exp \expr_2\type \Tint}}
    {\envs \tenv \tctx \exp \expr_1 \le \expr_2 \type \Tbool}
  \and
  \inferrule*[lab=T-lt]
    {{\envs \tenv \tctx \exp \expr_1\type \Tint} \and {\envs \tenv \tctx \exp \expr_2\type \Tint}}
    {\envs \tenv \tctx \exp \expr_1 < \expr_2 \type \Tbool}
  \and
  \inferrule*[lab=T-eq]
    {{\envs \tenv \tctx \exp \expr_1\type \Tint} \and {\envs \tenv \tctx \exp \expr_2\type \Tint}}
    {\envs \tenv \tctx \exp \expr_1 = \expr_2 \type \Tbool}
  \and
  \inferrule*[lab=T-true]{ }{\envs \tenv \tctx \exp \True \type \Tbool}
  \and
  \inferrule*[lab=T-false]{ }{\envs \tenv \tctx \exp \False \type \Tbool}
  \and
  \inferrule*[lab=T-if]
    {{\envs \tenv \tctx \exp \expr_1 \type \Tbool} \and
    {\envs \tenv \tctx \exp \expr_2 \type \typ} \and
    {\envs \tenv \tctx \exp \expr_3 \type \typ}}
    {\envs \tenv \tctx \exp {\If \expr_1 then \expr_2 else \expr_3} \type \typ}
  \and
  \inferrule*[lab=T-pair]
    {{\envs \tenv \tctx \exp \expr_1 \type \typ_1} \and
    {\envs \tenv \tctx \exp \expr_2 \type \typ_2}}
    {\envs \tenv \tctx \exp (\expr_1, \expr_2) \type \Tprod{\typ_1}{\typ_1}}
  \and
  \inferrule*[lab=T-fst]
    {\envs \tenv \tctx \exp \expr \type \Tprod{\typ_1}{\typ_2}}
    {\envs \tenv \tctx \exp \Fst \expr \type \typ_1}
  \and
  \inferrule*[lab=T-snd]
    {\envs \tenv \tctx \exp \expr \type \Tprod{\typ_1}{\typ_2}}
    {\envs \tenv \tctx \exp \Snd \expr \type \typ_2}
  \and
  \inferrule*[lab=T-inj1]{\envs \tenv \tctx \exp \expr \type \typ_1}
    {\envs \tenv \tctx \exp \Inj{1} \expr \type \Tsum{\typ_1}{\typ_2}}
  \and
  \inferrule*[lab=T-inj2]{\envs \tenv \tctx \exp \expr \type \typ_2}
    {\envs \tenv \tctx \exp \Inj{2} \expr \type \Tsum{\typ_1}{\typ_2}}
  \and
  \inferrule*[lab=T-match]
    {{\envs \tenv \tctx \exp \expr_1 \type \Tsum{\typ_1}{\typ_2}} \and
    {\envs \tenv \tctx, \var : \typ_1 \exp \expr_2 \type \typ} \and
    {\envs \tenv \tctx, \var : \typ_2 \exp \expr_3 \type \typ}
    }
    {\envs \tenv \tctx \exp {\Match \expr_1 with \Inj{1} \var => \expr_2 | \Inj{2} \var => \expr_3 end} \type \typ}
  \and
  \inferrule*[lab=T-rec]
    {\envs \tenv \tctx, f : \Tfunc{\typ_1}{\typ_2}, x : \typ_1 \exp e \type \typ_2}
    {\envs \tenv \tctx \exp \Rec f \var := \expr \type \Tfunc{\typ_1}{\typ_2}}
  \and
  \inferrule*[lab=T-app]
    {{\envs \tenv \tctx \exp \expr_1 \type \Tfunc{\typ_1}{\typ_2}} \and
    {\envs \tenv \tctx \exp \expr_2 \type \typ_1}
    }
    {\envs \tenv \tctx \exp \expr_1 \; \expr_2 \type \typ_2}
  \and
  \inferrule*[lab=T-Tlam]
    {\envs {\tenv, \Tvar} \tctx \exp \expr \type \typ}
    {\envs \tenv \tctx \exp \Tlam \expr \type \Tall{\Tvar}{\typ}}
  \and
  \inferrule*[lab=T-Tapp]
  {\envs \tenv \tctx \exp \expr \type \Tall{\Tvar}{\typ}}
  {\envs \tenv \tctx \exp \Tapp{\expr} \type \subst{\typ}{\Tvar}{\typ'}}
\end{mathpar}
\newpage
Dynamics
\begin{mathpar}
  \inferrule*[lab=head-step-step]
    {\hstepRel{\expr}{\expr'}}
    {\elctx[\expr] \step \elctx[\expr']}
\end{mathpar}

\begin{mathpar}
  \inferrule*[lab=E-add]{}
    {\hstepRel{\Num{n_1} + \Num{n_2}} {\Num{n_1 + n_2}}}
  \and
  \inferrule*[lab=E-sub]{}
    {\hstepRel{\Num{n_1} - \Num{n_2}} {\Num{n_1 - n_2}}}
  \and
  \inferrule*[lab=E-eq]{n_1 = n_2}
    {\hstepRel{\Num{n_1} = \Num{n_2}} {\True}}
  \and
  \inferrule*[lab=E-not-eq]{n_1 \neq n_2}
    {\hstepRel{\Num{n_1} = \Num{n_2}} {\False}}
  \and
  \inferrule*[lab=E-le]{n_1 \le n_2}
    {\hstepRel{\Num{n_1} \le \Num{n_2}} {\True}}
  \and
  \inferrule*[lab=E-not-le]{n_1 \not\le n_2}
    {\hstepRel{\Num{n_1} \le \Num{n_2}} {\False}}
  \and
  \inferrule*[lab=E-lt]{n_1 < n_2}
    {\hstepRel{\Num{n_1} < \Num{n_2}} {\True}}
  \and
  \inferrule*[lab=E-not-lt]{n_1 \not< n_2}
    {\hstepRel{\Num{n_1} < \Num{n_2}} {\False}}
  \and
  \inferrule*[lab=E-if-true]{}
    {\hstepRel{\If \True then \expr_2 else \expr_3} {\expr_2}}
  \and
  \inferrule*[lab=E-if-false]{}
    {\hstepRel{\If \False then \expr_2 else \expr_3} {\expr_3}}
  \and
  \inferrule*[lab=E-fst]{}
    {\hstepRel{\Fst (\val_1, \val_2)} {\val_1}}
  \and
  \inferrule*[lab=E-snd]{}
    {\hstepRel{\Snd (\val_1, \val_2)} {\val_2}}
  \and
  \inferrule*[lab=E-match-inj1]{}
    {\hstepRel{\Match (\Inj{1} \val) with \Inj{1} \var => \expr_2 | \Inj{2} \var => \expr_3 end}
     {\subst{\expr_2}{\var}{\val}}}
  \and
  \inferrule*[lab=E-match-inj2]{}
    {\hstepRel{\Match (\Inj{2} \val) with \Inj{1} \var => \expr_2 | \Inj{2} \var => \expr_3 end}
     {\subst{\expr_3}{\var}{\val}}}
  \and
  \inferrule*[lab=E-rec-app]{}
    {\hstepRel{(\Rec f \var := \expr) \val}
    {\subst{\subst{\expr}{f}{\Rec f \var := \expr}}{\var}{\val}}
    }
  \and
  \inferrule*[lab=E-tapp-tlam]{}{\hstepRel{\Tapp{(\Tlam \expr)}}
  {\expr}}
\end{mathpar}


% NOTES

% language is non-terminating. We can define \omega.

% types are curry-style: types are a property of a program in a language.
%   We can run the program without ever thinking about types. We can run it
%   even if we have type errors!

\begin{lemma}\label{lem:headstep_val}
  $\elctx[\expr] \hstep \expr' \land \neg (\elctx = \empelctx) \implies \Val{e}$
\end{lemma}

\begin{proof}
  This can be shown by doing case distinction on the head-step $\elctx[\expr] \hstep \expr'$. We show it here only for case E-ADD, as all the other cases are similar. \medskip\\
  So assume $\elctx[\expr] = \Num{n_1} + \Num{n_2}$, and $\expr' = \Num{n_1 + n_2}$.
  Then there are three cases: $\elctx = []$ and $\expr = \Num{n_1} + \Num{n_2}$, $\elctx = [] + \Num{n_2}$ and $\expr = \Num{n_1}$, or $\elctx = \Num{n_1} + []$ and $\expr = \Num{n_2}$. The first case raises a contradiction as we have assumed $\neg (\elctx = \empelctx)$. In the remaining two cases, we may conclude $\Val{\expr}$, as wanted.
\end{proof}


\begin{lemma}[Evaluation under Context]\label{lem:EuC}
  $ \elctx[\expr] \stepS \expr' \implies 
    \exists \expr'' . (\expr \stepS \expr'') \land\\
    \left( (\Val{\expr''} \land \elctx[\expr''] \stepS \expr') \lor
    (\neg \Val{\expr''} \land \elctx[\expr''] = \expr') \right)
    $
\end{lemma}

\begin{proof}
  So assuming $\elctx[\expr] \stepS \expr'$, we must show
  \begin{equation}\label{eqn:EuCGoal}
    \exists \expr'' . (\expr \stepS \expr'') \land 
    \left( (\Val{\expr''} \land \elctx[\expr''] \stepS \expr') \lor
    (\neg \Val{\expr''} \land \elctx[\expr''] = \expr') \right)
  \end{equation}
  We proceed by induction on the number of steps in the evaluation $\elctx[\expr] \stepS \expr'$. Let $n$ denote the number of steps taken, so that $\elctx[\expr] \step^n \expr'$.
  \begin{itemize}
    \item Base Case $n = 0$. In this case, we have that $\elctx[\expr] \step^0 \expr'$, which means that $\elctx[\expr] = \expr'$. Now use $\expr$ for $\expr''$ in \ref{eqn:EuCGoal}. We must show
    \begin{equation*}
      (\expr \stepS \expr) \land 
      \left( (\Val{\expr} \land \elctx[\expr] \stepS \expr') \lor
      (\neg \Val{\expr} \land \elctx[\expr] = \expr') \right)
    \end{equation*}
    Trivially, $\expr \stepS \expr$. For the second part, we proceed by case distinction on $\Val{\expr}$.
    \begin{itemize}
      \item $\Val{\expr}$. We have that $\elctx[\expr] \step^0 \expr'$, so $\elctx[\expr] \stepS \expr'$. Thus, we have $\Val{\expr} \land \elctx[\expr] \stepS \expr'$, which matches the left part of the "$\lor$".
      \item $\neg \Val{\expr}$. We know that $\elctx[\expr] = \expr'$, so we have $\neg \Val{\expr} \land \elctx[\expr] = \expr'$, which matches the right part of the "$\lor$".
    \end{itemize}
    
    \item Inductive Step $n = m + 1$. Now we have $\elctx[\expr] \step^{m + 1} \expr'$. By the Induction Hypothesis, we have:
    \begin{multline}\label{eqn:EuCIH}
      \forall F, f, f'. F[f] \step^m f' \implies \exists f'' . (f \stepS f'') \land \\
      \left( (\Val{f''} \land F[f''] \stepS f') \lor
      (\neg \Val{f''} \land \elctx[f''] = f') \right)
    \end{multline}
    Split the evaluation, $\elctx[\expr] \step^{m + 1} \expr'$, up, so that 
    $\elctx[\expr] \step g \land g \step^{m} \expr'$. Looking at our dynamics, we must have that $\elctx[\expr] = H[h]$, and $g = H[h']$, for some evaluation context $H$, and expressions $h$, $h'$, and $h \hstep h'$.
    There are now three possible cases. Either $\expr = h$, $\expr$ is a superexpression of $h$, or $\expr$ is a subexpression of $h$. We will consider each in turn.
    \begin{itemize}
      \item $\elctx = H$ and $\expr = h$.\\
        Then $g = H[h'] = \elctx[h']$, and $\expr \hstep h'$. 
        Furthermore, $\elctx[h'] \step^m \expr'$. Instantiate I.H. with this to get
        \begin{multline}\label{eqn:EuCC1IH}
          \exists f'' . (h' \stepS f'') \land\\
          \left((\Val{f''} \land \elctx[f''] \stepS \expr') \lor
          (\neg \Val{f''} \land \elctx[f''] = \expr') \right)
        \end{multline}
        Call this quantified expression for $f''$, and use it for $\expr''$ in \ref{eqn:EuCGoal}. We must then show
        \begin{equation*}
          (\expr \stepS f'') \land 
          \left( (\Val{f''} \land \elctx[f''] \stepS \expr') \lor
          (\neg \Val{f''} \land \elctx[f''] = \expr') \right)
        \end{equation*}
        We know that $\expr \step h'$, as $\expr \hstep h'$, and by 
        \ref{eqn:EuCC1IH}, we know that $h' \stepS f''$, so that $\expr \stepS f''$. The second part follows directly from \ref{eqn:EuCC1IH}.
      
      \item $\elctx[E[]] = H$ and $\expr = E[h]$.\\
        Then $g = H[h'] = \elctx[E[]][h'] = \elctx[E[h']]$, thus $\elctx[E[h']] \step^m \expr'$. Instantiate I.H. with this to get
        \begin{multline}\label{eqn:EuCC2IH}
          \exists f'' . (E[h'] \stepS f'') \land\\
          \left((\Val{f''} \land \elctx[f''] \stepS \expr') \lor
          (\neg \Val{f''} \land \elctx[f''] = \expr') \right)
        \end{multline}
        Call this quantified expression for $f''$, and use it for $\expr''$ in \ref{eqn:EuCGoal}. We must then show
        \begin{equation*}
          (\expr \stepS f'') \land 
          \left( (\Val{f''} \land \elctx[f''] \stepS \expr') \lor
          (\neg \Val{f''} \land \elctx[f''] = \expr') \right)
        \end{equation*}
        We know that $E[h] \step E[h']$, as $h \hstep h'$, and since $\expr = E[h]$, then $\expr \step E[h']$. By 
        \ref{eqn:EuCC2IH}, we know that $E[h'] \stepS f''$, so that $\expr \stepS f''$. The second part follows directly from \ref{eqn:EuCC2IH}.

      \item $\elctx = H[E[]]$ and $E[\expr] = h$.
        Here we have $h = E[\expr]$, so $E[\expr] \hstep h'$. Note that $E$ is not the empty evaluation context, as otherwise, we would be in case 1. So by lemma \ref{lem:headstep_val}, we know that $\Val{\expr}$. Now, pick $\expr$ for $\expr''$ in \ref{eqn:EuCGoal}. We must show 
        \begin{equation*}
          (\expr \stepS \expr) \land 
          \left( (\Val{\expr} \land \elctx[\expr] \stepS \expr') \lor
          (\neg \Val{\expr} \land \elctx[\expr] = \expr') \right)
        \end{equation*}
        Trivially, $\expr \stepS \expr$. We also have that $\Val{\expr}$, and since $\elctx[\expr] \step^{m + 1} \expr'$, then $\elctx[\expr] \stepS \expr'$.
    \end{itemize}
  \end{itemize}

\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Contextual Equivalence}
\label{ch:CE}

\todo{draft}

Context
\begin{align*}
  \ctx \BNFdef& \empctx \ALT
                \ctx + \expr \ALT \expr + \ctx \ALT
                \ctx - \expr \ALT \expr - \ctx \ALT
                \ctx \le \expr \ALT \expr \le \ctx \ALT
                \ctx < \expr \ALT \expr < \ctx \ALT
                \ctx = \expr \ALT \expr = \ctx \ALT\\
              & {\If \ctx then \expr else \expr} \ALT
                {\If \expr then \ctx else \expr} \ALT
                {\If \expr then \expr else \ctx} \ALT
                (\ctx, \expr) \ALT (\expr, \ctx) \ALT\\
              & \Fst \ctx \ALT \Snd \ctx \ALT
                \Inj{1} \ctx \ALT \Inj{2} \ctx \ALT
                \Match \ctx with \Inj{1} \var => \expr | \Inj{2} \var => \expr end \ALT\\
              & \Match \expr with \Inj{1} \var => \ctx | \Inj{2} \var => \expr end \ALT\\
              & \Match \expr with \Inj{1} \var => \expr | \Inj{2} \var => \ctx end \ALT
              \Rec f \var := \ctx \ALT
              \ctx \; \expr \ALT \expr \; \ctx \ALT \Tlam \ctx \ALT \Tapp{\ctx}
\end{align*}

Context Typing
\begin{mathpar}
  \inferrule*[lab=T-ctx]
    { {\envs \tenv \tctx \exp \expr \type \typ} \and 
      {\envs {\tenv'} {\tctx'} \exp \ctx[\expr] \type {\typ'}}}
    {C : (\envstyp \tenv \tctx \type \typ) \Rightarrow (\envstyp {\tenv'} {\tctx'} \type {\typ'}) }
\end{mathpar}
Read as: the context takes an expression of type $\typ$ under $\tenv, \tctx$, and outputs an expression of type $\typ'$ under $\tenv', \tctx'$.
\begin{definition}[Contextual Equivalence]
  We define contextual equivalence of two expressions $\expr_1$ and $\expr_2$ at type $\typ$ under $\tenv$ and $\tctx$ as
  \begin{equation*}
    \begin{gathered}
      \envscteq \tenv \tctx \exp1 \expr_1 \exp2 \expr_2 \type \typ\\
      \iff\\
      \envs \tenv \tctx \exp \expr_1 \type \typ \quad \land \quad
      \envs \tenv \tctx \exp \expr_2 \type \typ \quad \land \quad\\
      \forall \ctx : (\envstyp \tenv \tctx \type \typ) \Rightarrow (\envstyp {\emptenv} {\emptctx} \type \Tunit) . (\ctx[\expr_1] \Downarrow \iff \ctx[\expr_2] \Downarrow)
    \end{gathered}
  \end{equation*}
\end{definition}


\todo{fix unfinished text passage - start}

We define CE so that two programs are CE iff under all Contexts, one program terminates iff the other does. One may ponder whether this definition is really strong enough. If both terminate, we really want the result of the two programs to have values that are behaviourally the same, otherwise, we can certainly put them in a context, where they have different behaviour.
For integer values, for example, this means that the two values must be the same number, and for product types, this means that the first value in each pair should be behaviourally the same, and likewise with the second value in each pair.
To give an intuition as to  why this definition is strong enough, consider two contextually equivalent programs $\expr_1$ and $\expr_2$, where $\envs \emptenv \emptctx \exp \expr_1 \type \typ$ and $\envs \emptenv \emptctx \exp \expr_2 \type \typ$.
Note first that if both $\expr_1$ and $\expr_2$ don't terminate, then they will be behaviourally the same; if we plug them into any context, and the context makes us evaluate the expressions, both will not terminate. And if the context doesn't make us evaluate the expressions, then they have no influence in the run of the programs, so they will behave the same.

Now consider what happens if $\expr_1$ terminates with some value $\val_1$. Can we then guarantee that $\expr_2$ also terminates with some value $\val_2$, and $\val_1$ and $\val_2$ behave the same? Since $\expr_1$ and $\expr_2$ are contextually equivalent, then we can put them into any context, $\ctx$, and one will terminate if and only if the other one does.
Let's assume that $\typ = \Tint$. Then consider when $\ctx$ has the form $\If \empctx = \val_1 then \TT else \omega$. Here $\ctx[\expr_1] \Downarrow \TT$. But what about $\ctx[\expr_2]$? If $\val_2 \neq \val_1$, then our evaluation rules tell us that we will take the else branch, and hence not terminate. However, since $\expr_1$ and $\expr_2$ are contextually equivalent, and $\ctx[\expr_1]$ terminates, then we know that $\ctx[\expr_2]$ must also terminate. Hence it is not the case that $\val_2 \neq \val_1$, thus $\val_2 = \val_1$. So if our two programs of type integer are contextually equivalent, and they both don't run forever, then they must both evaluate to the same number.

Now if $\typ$ was $\Tbool$ instead, the context $\If \empctx then \TT else \omega$ would suffice in showing that $\val_2 = \val_1$. 

It becomes a little more difficult to reason about when $\typ$ is not a base-type, like $\Tint$ or $\Tbool$. Take function type, for instance. If $\expr_1$ and $\expr_2$ both evaluate down to functions, how do we know that those functions are behaviourally equivalent (in the sense of functional extensionality)? To see this, consider the following congruence rule:
\begin{mathpar}
  \inferrule*[lab=Congruence-function-app]
  { { \envscteq \tenv \tctx \exp1 f \exp2 {f'} \type {\Tfunc{\typ}{\typ'}} } \and
    { \envscteq \tenv \tctx \exp1 t \exp2 {t'} \type {\typ} }
  }
  { \envscteq \tenv \tctx \exp1 f \; t \exp2 {f' \; t'} \type {\typ'} }
\end{mathpar}
This essentially gives us what we want: if we have two contextually equivalent functions, then, as long as we give them contextually equivalent inputs, the output will also be contextually equivalent. That output may be another function, but then this rule applies again to that output, and so on. In other words, we can keep on applying this rule until we at some point get a base type, like $\Tint$, and at that point, we know that the two numbers will be the same, by the argument made above.\\
Of course, it may happen that the output is of another non-base type, such as type abstraction. But we may do something similar for all other non-base types. However proving all of them is quite tedious, so we will here only prove the congruence rule for function types.
\begin{proof}
  By the two hypotheses of the rule, we know that $\envs \tenv \tctx \exp {f} \type \Tfunc{\typ}{\typ'}$ and $\envs \tenv \tctx \exp t \type \typ$. So by the T-APP rule, we may conclude $\envs \tenv \tctx \exp {f \; t} \type \typ'$. Likewise for the prime variants. So all that remains to be shown is that $\forall \ctx : (\envstyp \tenv \tctx \type \typ') \Rightarrow (\envstyp {\emptenv} {\emptctx} \type \Tunit) . (\ctx[f \; t] \Downarrow \iff \ctx[f' \; t'] \Downarrow)$. So assume some context, $\ctx$, of the right type. Consider now the context $\ctx[\empctx \; t]$. We know that $f$ is contextually equivalent to $f'$, so $\ctx[f \; t] \Downarrow \iff \ctx[f' \; t] \Downarrow$. Now consider the context $\ctx[f' \empctx]$. Since $t$ is contextually equivalent to $t'$, then we know $\ctx[f' \; t] \Downarrow \iff \ctx[f' \; t'] \Downarrow$. In other words, we have that $\ctx[f \; t] \Downarrow \iff \ctx[f' \; t] \iff \ctx[f' \; t'] \Downarrow$, which was what we wanted.
\end{proof}

An interesting point to note here is that one may define contextual equivalence in another, equivalent way. Namely by specifying contextual equivalence, $ctx-equiv$, to be a relation: $ctx-equiv \subseteq \tenv \times \tctx \times \expr \times \expr \times \typ$. It should then have two properties. It should be a congruence relation w.r.t. the typing rules (such as the one we did for function application), and it should be an adequate relation, stating that 
\todo{what is an adequate relation}. The proof we just did is one step in showing that the two ways of defining contextual equivalence are equivalent.


\todo{fix unfinished text passage - end}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Logical Relations Model for Contextual Equivalence}
\label{ch:LR}

\todo{draft}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Examples of Application of Contextual Equivalence}
\label{ch:ACE}

\todo{draft}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Comparison to Other Work and Ideas for Future Work}
\label{ch:COWFW}

\todo{draft}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}
\label{ch:conclusion}

\todo{conclude on the problem statement from the introduction}

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

\todo{\dots}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain} 
\bibliography{refs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{The Technical Details}

\todo{\dots}

\end{document}

