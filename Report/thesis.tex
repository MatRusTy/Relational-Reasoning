\documentclass[twoside,11pt,openright]{report}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
\usepackage{mathptmx}
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage[en-GB]{datetime2}
\DTMlangsetup[en-GB]{showdayofmonth=false}
\usepackage{lipsum}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BNF Grammar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\BNFdef}{::=}
\newcommand{\ALT}{~|~}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Syntax
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Keyword}[1]{{\color{blue} \mathsf{#1}}}

\newcommand{\var}{x}
\newcommand{\varB}{y}
\newcommand{\varC}{z}
\newcommand{\expr}{e}
\newcommand{\val}{v}
\newcommand{\valB}{w}
\newcommand{\TT}{()}
\newcommand{\Num}[1]{\overline{#1}}
\newcommand{\True}{\Keyword{true}}
\newcommand{\False}{\Keyword{false}}
\newcommand{\IfCmd}{\Keyword{if}}
\newcommand{\ThenCmd}{\Keyword{then}}
\newcommand{\ElseCmd}{\Keyword{else}}
\def\If#1then#2else#3{\IfCmd{}\;#1\;\ThenCmd{}\;#2\;\ElseCmd{}\;#3}
\newcommand{\Fst}{\Keyword{fst}\;}
\newcommand{\Snd}{\Keyword{snd}\;}
\newcommand{\Inj}[1]{\Keyword{inj}_{#1}\;}
\newcommand{\MatchCmd}{\Keyword{match}}
\newcommand{\WithCmd}{\Keyword{with}}
\newcommand{\EndCmd}{\Keyword{end}}
\def\Match#1with#2=>#3|#4=>#5end{\MatchCmd{}\;#1\;\WithCmd{}\;#2\Rightarrow#3 \;|\;#4\Rightarrow#5\;\EndCmd{}}
\def\MatchV[#1]#2with#3=>#4|#5=>#6end{\begin{aligned}[#1]&\MatchCmd{}\;#2\;\WithCmd{}\\ & \hspace{0.5em}#3\Rightarrow#4\\ & | \hspace{0.2em}#5\Rightarrow#6\\ &\EndCmd{}\end{aligned}}
\newcommand{\RecCmd}{\Keyword{rec}}
\long\def\Rec#1 #2:=#3{\RecCmd\; #1(#2) := #3}

\newcommand{\Tvar}{X}
\newcommand{\TvarB}{Y}
\newcommand{\TvarC}{Z}

\newcommand{\Tlam}{\Lambda\;}
\newcommand{\Tapp}[1]{#1\;\_}

\newcommand{\empelctx}{[]}
\newcommand{\elctx}{K}

\newcommand{\subst}[3]{#1{\left[#3 \middle/ #2 \right]}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Typing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\Tunit}{\mathsf{Unit}}
\newcommand{\Temp}{\mathsf{Emp}}
\newcommand{\Tnat}{\mathbb{N}} % not needed
\newcommand{\Tint}{\mathbb{Z}}
\newcommand{\Tbool}{\mathbb{B}}
\newcommand{\Tprod}[2]{#1 \times #2}
\newcommand{\Tsum}[2]{#1 + #2}
\newcommand{\Tfunc}[2]{#1 \rightarrow #2}
\newcommand{\Tall}[2]{\forall #1.\; #2}

\newcommand{\typ}{\tau}
\newcommand{\ctx}{\Gamma}
\newcommand{\tctx}{\Xi}
\newcommand{\hctx}{\Sigma} % not needed

% Judgement
\def\envs#1#2\exp#3\type#4{#1 \; | \; #2 \; \vdash #3 : #4}

% Head-Step
\newcommand{\hstep}[2]{#1 \rightarrow_h #2}

% TODO-command
\newcommand{\todo}[1]{{\color[rgb]{.5,0,0}\textbf{$\blacktriangleright$#1$\blacktriangleleft$}}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
{\Huge\sf Relational Reasoning\\[1ex](Relationel r√¶sonnement)}\\[4ex]
{\huge\sf Mathias Pedersen, 201808137}\\[2ex]
\noindent\rule{\linewidth}{1mm}\\[4ex]
\noindent{\Large\sf Bachelor Report (15 ECTS) in Computer Science\\[1ex]
Advisor: Amin Timany\\[1ex]
Department of Computer Science, Aarhus University\\[1ex]  
\today \\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage
\linespread{1.15}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

\todo{in English\dots}

\vspace{2ex}
\begin{flushright}
  \emph{Mathias Pedersen,}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\label{ch:intro}

\todo{motivate and explain the problem to be addressed}

\todo{example of a citation: \cite{DBLP:conf/sas/ChristensenMS03}}
\todo{get your bibtex entries from \url{https://dblp.org/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Definition of Language}
\label{ch:DoL}

\todo{create draft}\\
Syntax
\begin{align*}
  \expr \BNFdef & \TT \ALT & \text{(unit value)}\\
                & \var \ALT & \text{(variables)}\\
                & \Num{n} \ALT \expr + \expr \ALT \expr - \expr \ALT
                  \expr \le \expr \ALT \expr < \expr \ALT 
                  \expr = \expr \ALT & \text{(integers)}\\
                & \True \ALT \False \ALT {\If \expr then \expr else \expr} \ALT
                  & \text{(booleans)}\\
                & (\expr, \expr) \ALT \Fst \expr \ALT \Snd \expr \ALT
                  & \text{(products)}\\
                & \Inj{1} \expr \ALT \Inj{2} \expr \ALT 
                  \Match \expr with \Inj{1} \var => \expr | \Inj{2} \var => \expr end \ALT
                  & \text{(sums)}\\
                & \Rec f \var := \expr \ALT \expr \; \expr
                  & \text{(recursive functions)}\\
                & \Tlam \expr \ALT \Tapp{\expr} & \text{(polymorphism)}\\[8pt]
  \val \BNFdef  & \TT \ALT \Num{n} \ALT \True \ALT \False \ALT
                  (\val, \val) \ALT \Inj{1} \val \ALT \Inj{2} \val \ALT
                  \Rec f \var := \expr \ALT \Tlam \expr
                  & \text{(values)}\\[8pt]
  \typ \BNFdef  & \Tunit \ALT \Tint \ALT \Tbool \ALT {\Tprod \typ \typ} \ALT
                  {\Tsum \typ \typ} \ALT {\Tfunc \typ \typ} \ALT 
                  {\Tall \Tvar \typ} & \text{(types)}\\[8pt]
  \elctx \BNFdef& \empelctx \ALT 
                  \elctx + \expr \ALT \val + \elctx \ALT
                  \elctx - \expr \ALT \val - \elctx \ALT
                  \elctx \le \expr \ALT \val \le \elctx \ALT
                  \elctx < \expr \ALT \val < \elctx \ALT 
                  & \text{(evaluation context)}\\
                & \elctx = \expr \ALT \val = \elctx \ALT
                  {\If \elctx then \expr else \expr} \ALT
                  (\elctx, \expr) \ALT (\val, \elctx) \ALT
                  \Fst \elctx \ALT \Snd \elctx \ALT\\
                & \Inj{1} \elctx \ALT \Inj{2} \elctx \ALT
                  \Match \elctx with \Inj{1} \var => \expr | \Inj{2} \var => \expr end \ALT
                  \elctx \; \expr \ALT \val \; \elctx \ALT \Tapp{\elctx}
\end{align*}
\newpage
Typing rules
\begin{mathpar}
  \inferrule*[lab=T-var]
    {(\var : \typ) \in \ctx}
    {\envs \tctx \ctx \exp \var \type \typ}
  \and
  \inferrule*[lab=T-unit]{ }{\envs \tctx \ctx \exp \TT \type \Tunit}
  \and
  \inferrule*[lab=T-int]{ }{\envs \tctx \ctx \exp \Num{n} \type \Tint}
  \and
  \inferrule*[lab=T-add]
    {{\envs \tctx \ctx \exp \expr_1\type \Tint} \and {\envs \tctx \ctx \exp \expr_2\type \Tint}}
    {\envs \tctx \ctx \exp \expr_1 + \expr_2 \type \Tint}
  \and
  \inferrule*[lab=T-sub]
    {{\envs \tctx \ctx \exp \expr_1\type \Tint} \and {\envs \tctx \ctx \exp \expr_2\type \Tint}}
    {\envs \tctx \ctx \exp \expr_1 - \expr_2 \type \Tint}
  \and
  \inferrule*[lab=T-le]
    {{\envs \tctx \ctx \exp \expr_1\type \Tint} \and {\envs \tctx \ctx \exp \expr_2\type \Tint}}
    {\envs \tctx \ctx \exp \expr_1 \le \expr_2 \type \Tbool}
  \and
  \inferrule*[lab=T-lt]
    {{\envs \tctx \ctx \exp \expr_1\type \Tint} \and {\envs \tctx \ctx \exp \expr_2\type \Tint}}
    {\envs \tctx \ctx \exp \expr_1 < \expr_2 \type \Tbool}
  \and
  \inferrule*[lab=T-eq]
    {{\envs \tctx \ctx \exp \expr_1\type \Tint} \and {\envs \tctx \ctx \exp \expr_2\type \Tint}}
    {\envs \tctx \ctx \exp \expr_1 = \expr_2 \type \Tbool}
  \and
  \inferrule*[lab=T-true]{ }{\envs \tctx \ctx \exp \True \type \Tbool}
  \and
  \inferrule*[lab=T-false]{ }{\envs \tctx \ctx \exp \False \type \Tbool}
  \and
  \inferrule*[lab=T-if]
    {{\envs \tctx \ctx \exp \expr_1 \type \Tbool} \and
    {\envs \tctx \ctx \exp \expr_2 \type \typ} \and
    {\envs \tctx \ctx \exp \expr_3 \type \typ}}
    {\envs \tctx \ctx \exp {\If \expr_1 then \expr_2 else \expr_3} \type \typ}
  \and
  \inferrule*[lab=T-pair]
    {{\envs \tctx \ctx \exp \expr_1 \type \typ_1} \and
    {\envs \tctx \ctx \exp \expr_2 \type \typ_2}}
    {\envs \tctx \ctx \exp (\expr_1, \expr_2) \type \Tprod{\typ_1}{\typ_1}}
  \and
  \inferrule*[lab=T-fst]
    {\envs \tctx \ctx \exp \expr \type \Tprod{\typ_1}{\typ_2}}
    {\envs \tctx \ctx \exp \Fst \expr \type \typ_1}
  \and
  \inferrule*[lab=T-snd]
    {\envs \tctx \ctx \exp \expr \type \Tprod{\typ_1}{\typ_2}}
    {\envs \tctx \ctx \exp \Snd \expr \type \typ_2}
  \and
  \inferrule*[lab=T-inj1]{\envs \tctx \ctx \exp \expr \type \typ_1}
    {\envs \tctx \ctx \exp \Inj{1} \expr \type \Tsum{\typ_1}{\typ_2}}
  \and
  \inferrule*[lab=T-inj2]{\envs \tctx \ctx \exp \expr \type \typ_2}
    {\envs \tctx \ctx \exp \Inj{2} \expr \type \Tsum{\typ_1}{\typ_2}}
  \and
  \inferrule*[lab=T-match]
    {{\envs \tctx \ctx \exp \expr_1 \type \Tsum{\typ_1}{\typ_2}} \and
    {\envs \tctx \ctx, \var : \typ_1 \exp \expr_2 \type \typ} \and
    {\envs \tctx \ctx, \var : \typ_2 \exp \expr_3 \type \typ}
    }
    {\envs \tctx \ctx \exp {\Match \expr_1 with \Inj{1} \var => \expr_2 | \Inj{2} \var => \expr_3 end} \type \typ}
  \and
  \inferrule*[lab=T-rec]
    {\envs \tctx \ctx, f : \Tfunc{\typ_1}{\typ_2}, x : \typ_1 \exp e \type \typ_2}
    {\envs \tctx \ctx \exp \Rec f \var := \expr \type \Tfunc{\typ_1}{\typ_2}}
  \and
  \inferrule*[lab=T-app]
    {{\envs \tctx \ctx \exp \expr_1 \type \Tfunc{\typ_1}{\typ_2}} \and
    {\envs \tctx \ctx \exp \expr_2 \type \typ_1}
    }
    {\envs \tctx \ctx \exp \expr_1 \; \expr_2 \type \typ_2}
  \and
  \inferrule*[lab=T-Tlam]
    {\envs {\tctx, \Tvar} \ctx \exp \expr \type \typ}
    {\envs \tctx \ctx \exp \Tlam \expr \type \Tall{\Tvar}{\typ}}
  \and
  \inferrule*[lab=T-Tapp]
  {\envs \tctx \ctx \exp \expr \type \Tall{\Tvar}{\typ}}
  {\envs \tctx \ctx \exp \Tapp{\expr} \type \subst{\typ}{\Tvar}{\typ'}}
\end{mathpar}
\newpage
Dynamics
\begin{mathpar}
  \inferrule*[lab=head-step-step]
    {\hstep{\expr}{\expr'}}
    {\elctx[\expr] \rightarrow \elctx[\expr']}
\end{mathpar}

\begin{mathpar}
  \inferrule*[lab=E-add]{}
    {\hstep{\Num{n_1} + \Num{n_2}} {\Num{n_1 + n_2}}}
  \and
  \inferrule*[lab=E-sub]{}
    {\hstep{\Num{n_1} - \Num{n_2}} {\Num{n_1 - n_2}}}
  \and
  \inferrule*[lab=E-eq]{n_1 = n_2}
    {\hstep{\Num{n_1} = \Num{n_2}} {\True}}
  \and
  \inferrule*[lab=E-not-eq]{n_1 \neq n_2}
    {\hstep{\Num{n_1} = \Num{n_2}} {\False}}
  \and
  \inferrule*[lab=E-le]{n_1 \le n_2}
    {\hstep{\Num{n_1} \le \Num{n_2}} {\True}}
  \and
  \inferrule*[lab=E-not-le]{n_1 \not\le n_2}
    {\hstep{\Num{n_1} \le \Num{n_2}} {\False}}
  \and
  \inferrule*[lab=E-lt]{n_1 < n_2}
    {\hstep{\Num{n_1} < \Num{n_2}} {\True}}
  \and
  \inferrule*[lab=E-not-lt]{n_1 \not< n_2}
    {\hstep{\Num{n_1} < \Num{n_2}} {\False}}
  \and
  \inferrule*[lab=E-if-true]{}
    {\hstep{\If \True then \expr_2 else \expr_3} {\expr_2}}
  \and
  \inferrule*[lab=E-if-false]{}
    {\hstep{\If \False then \expr_2 else \expr_3} {\expr_3}}
  \and
  \inferrule*[lab=E-fst]{}
    {\hstep{\Fst (\val_1, \val_2)} {\val_1}}
  \and
  \inferrule*[lab=E-snd]{}
    {\hstep{\Snd (\val_1, \val_2)} {\val_2}}
  \and
  \inferrule*[lab=E-match-inj1]{}
    {\hstep{\Match (\Inj{1} \val) with \Inj{1} \var => \expr_2 | \Inj{2} \var => \expr_3 end}
     {\subst{\expr_2}{\var}{\val}}}
  \and
  \inferrule*[lab=E-match-inj2]{}
    {\hstep{\Match (\Inj{2} \val) with \Inj{1} \var => \expr_2 | \Inj{2} \var => \expr_3 end}
     {\subst{\expr_3}{\var}{\val}}}
  \and
  \inferrule*[lab=E-rec-app]{}
    {\hstep{(\Rec f \var := \expr) \val}
    {\subst{\subst{\expr}{f}{\Rec f \var := \expr}}{\var}{\val}}
    }
  \and
  \inferrule*[lab=E-tapp-tlam]{}{\hstep{\Tapp{(\Tlam \expr)}}
  {\expr}}
\end{mathpar}


% NOTES

% language is non-terminating. We can define \omega.

% types are curry-style: types are a property of a program in a language.
%   We can run the program without ever thinking about types. We can run it
%   even if we have type errors!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Contextual Equivalence}
\label{ch:CE}

\todo{draft}


% NOTES

% Non-terminating language and contextual equivalence?
%   it is non-terminating. define contextual eq as going to closed unit...
%   see google photo.


% We define CE so that two programs are CE iff under all Contexts,
% one program terminates iff the other does.
% One may ponder whether this definition is really strong enough.
% If both terminate, we really want the result of the two programs to have
% values that are behaviourally the same, otherwise, we can certainly 
% put them in a context, where they have different behaviour.
% For integer values, for example, this means that the two values
% must be the same number.
% To see why this definition is strong enough, consider two 
% CE programs e1 and e2, where |- e1 : tau and |- e2 : tau.
% Note first that if both e1 and e2 doesn't terminate, then they will be
% behaviourally the same. If we plug them into any context, and the context
% makes us evaluate the expressions, both will not terminate. And if the
% context doesn't make us evaluate the expressions, then they have no
% influence in the run of the programs, so they will behave the same.

% Now consider what happens if e1 terminates with some value v1. 
% Can we then guarantee that e2 also terminates with some value v2,
% and v1 and v2 behave the same?
% Since e1 and e2 are CE, then we can put them into any context, C, and 
% one will terminate iff the other one does. 
% Let's first assume that tau = Z. Then consider when 
% C has the form  if [] = v1 then () else \omega.
% Here C[e1] \downarrow (). But what about C[e2]? If v2 != v1, then
% our evaluation rules tell us that we will take the else branch, and
% hence not terminate. However, since e1 and e2 are CE, and C[e1] terminates
% then we know that C[e2] must also terminate. Hence it is not the case that
% v2 != v1, and thus v2 = v1. So if our two programs of type integer are CE,
% they both don't run forever, then they must both evaluate to the same value.

% Now if tau was bool instead, the context if [] then () else \omega
% would suffice in showing that v2 = v1. 

% UNSURE
% And for all the other types, we would also be able to create contexts,
% that ensured that the two programs terminated with values that have
% similar behaviour.
% UNSURE


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Logical Relations for Contextual Equivalence}
\label{ch:LR}

\todo{draft}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Examples of Application of Contextual Equivalence}
\label{ch:ACE}

\todo{draft}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Comparison to Other Work and Ideas for Future Work}
\label{ch:COWFW}

\todo{draft}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}
\label{ch:conclusion}

\todo{conclude on the problem statement from the introduction}

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

\todo{\dots}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain} 
\bibliography{refs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{The Technical Details}

\todo{\dots}

\end{document}

